#include "transceiverGUI.hpp"

using namespace pylongps;
using namespace Marble;

/**
This function initializes the class, connecting widgets, setting up the form generated by Qt designer and adding the components that the designer doesn't handle well.

@throw: This function can throw exceptions
*/
transceiverGUI::transceiverGUI()
{
setupUi(this);

SOM_TRY
context.reset(new zmq::context_t);
SOM_CATCH("Error, unable to make ZMQ context\n")

//Set buttons to switch the pages in the GUI
connect(toggleGUIPagePushButtonP1, SIGNAL(clicked(bool)), this, SLOT(toggleGUIPage()));
connect(toggleGUIPagePushButtonP2, SIGNAL(clicked(bool)), this, SLOT(toggleGUIPage()));

//Add a scrolly map without any other features
mapWidget = new Marble::MarbleWidget();
mapWidget->setProjection(Marble::Mercator);
mapWidget->setMapThemeId("earth/openstreetmap/openstreetmap.dgml");
mapWidget->setShowOverviewMap(false);
mapWidget->setShowCompass(false);
mapWidget->setShowScaleBar(false);
mapWidget->setShowCrosshairs(false);
mapWidget->setShowGrid(false);
mapWidget->centerOn(0.0,0.0);

//Hide navigator tool
QList<Marble::AbstractFloatItem *> floatItems = mapWidget->floatItems();
for(int i=0; i<floatItems.size(); i++)
{
floatItems.at(i)->hide();
}


baseStationMapLayout->addWidget(mapWidget);

mapWidget->setDistance(15);

//Create thread to redirect map/update basestations based on the lat/lon retrieved for the current IP
QThread *thread = new QThread;
IPBasedLocationRetriever *retriever = new IPBasedLocationRetriever;
retriever->moveToThread(thread);
connect(thread, SIGNAL(started()), retriever, SLOT(operate()));
connect(retriever, SIGNAL(finished()), thread, SLOT(quit()));
connect(retriever, SIGNAL(finished()), thread, SLOT(deleteLater()));
connect(thread, SIGNAL(finished()), thread, SLOT(deleteLater()));
connect(retriever, SIGNAL(retrievedLongitudeLatitude(double, double)), mapWidget, SLOT(centerOn(double, double)));
thread->start();

connect(mapWidget, SIGNAL(visibleLatLonAltBoxChanged(const GeoDataLatLonAltBox &)), this, SLOT(regionChanged(const GeoDataLatLonAltBox &)));

connect(mapWidget, SIGNAL(visibleLatLonAltBoxChanged(const GeoDataLatLonAltBox &)), this, SLOT(updateMapViewAccordingToBasestationModel()));
/*
//Create thread to redirect map/update basestations based on the lat/lon retrieved for the given address
QThread *thread = new QThread;
addressBasedLocationRetriever *addressRetriever = new addressBasedLocationRetriever("2043 Elizabeth Ave, Winston Salem NC 27103");
addressRetriever->moveToThread(thread);
connect(thread, SIGNAL(started()), addressRetriever, SLOT(operate()));
connect(addressRetriever, SIGNAL(finished()), thread, SLOT(quit()));
connect(addressRetriever, SIGNAL(finished()), thread, SLOT(deleteLater()));
connect(thread, SIGNAL(finished()), thread, SLOT(deleteLater()));
connect(addressRetriever, SIGNAL(retrievedLongitudeLatitude(double, double)), mapWidget, SLOT(centerOn(double, double)));
thread->start();
*/
} 

/**
This function toggles which page is displayed in the GUI.  If the current index is 0, it makes it 1 and vice versa.
*/
void transceiverGUI::toggleGUIPage()
{
if(mainWindowStackedWidget->count() > 1)
{ //Toggle the index
mainWindowStackedWidget->setCurrentIndex(!mainWindowStackedWidget->currentIndex());
}
}

/**
This function updates the visible basestation list and emits the visibleBasestationListChanged signal if the list changes.
@param inputVisibleRegion: A structure defining where on the earth is currently visible in the screen
*/
void transceiverGUI::regionChanged(const GeoDataLatLonAltBox &inputVisibleRegion)
{
printf("Region changed: %lf %lf %lf %lf\n", inputVisibleRegion.west()*180.0/pylongps::PI, inputVisibleRegion.north()*180.0/pylongps::PI, inputVisibleRegion.east()*180.0/pylongps::PI, inputVisibleRegion.south()*180.0/pylongps::PI);
currentMapBoundaries = std::array<double, 4>{inputVisibleRegion.west(), inputVisibleRegion.north(), inputVisibleRegion.east(), inputVisibleRegion.south()};

std::array<double, 4> boundaries;
bool cacheExpired = false;
{
//Lock mutex
std::lock_guard<std::mutex> lockGuard(visibleBasestationMutex);

if(
((fmax(inputVisibleRegion.west(), inputVisibleRegion.east()) > fmax(lastQueryBoundaryInRadians[0], lastQueryBoundaryInRadians[2]) ||
fmin(inputVisibleRegion.west(), inputVisibleRegion.east()) > fmin(lastQueryBoundaryInRadians[0], lastQueryBoundaryInRadians[2]) ||
fmax(inputVisibleRegion.north(), inputVisibleRegion.south()) > fmax(lastQueryBoundaryInRadians[1], lastQueryBoundaryInRadians[3]) ||
fmin(inputVisibleRegion.north(), inputVisibleRegion.south()) > fmin(lastQueryBoundaryInRadians[1], lastQueryBoundaryInRadians[3]) || ((timeOfLastQueryUpdate + TRANSCEIVER_GUI_EXPIRATION_TIME) > Poco::Timestamp())) && 
(timeOfLastSentQuery + TRANSCEIVER_GUI_MINIMUM_TIME_BETWEEN_QUERIES) < Poco::Timestamp() )
)
{
printf("Time of last sent query: %ld %ld %d\n", (timeOfLastQueryUpdate + TRANSCEIVER_GUI_EXPIRATION_TIME).elapsed(), Poco::Timestamp().elapsed(), (timeOfLastSentQuery + TRANSCEIVER_GUI_MINIMUM_TIME_BETWEEN_QUERIES) < Poco::Timestamp());
cacheExpired = true;
boundaries = {inputVisibleRegion.west()*TRANSCEIVER_QUERY_CACHING_CONSTANT, inputVisibleRegion.north()*TRANSCEIVER_QUERY_CACHING_CONSTANT, inputVisibleRegion.east()*TRANSCEIVER_QUERY_CACHING_CONSTANT, inputVisibleRegion.south()*TRANSCEIVER_QUERY_CACHING_CONSTANT};
printf("Yowsers\n");
}
else
{
//Clear current tags and update the map widget to show the currently visible basestations (apply to widget bar too)
}


} //Mutex unlocked

if(cacheExpired)
{
//The cache is out of date or does not cover where we are currently looking, so spawn a thread to update it and then exit
Poco::Net::HostEntry host;

SOM_TRY
host = Poco::Net::DNS::hostByName("www.pylongps.com");
SOM_CATCH("Error, unable to resolve URL\n")

if(host.addresses().size() == 0)
{
return;
}

basestationListRetriever *retriever = new basestationListRetriever(*this, boundaries, "tcp://" + host.addresses()[0].toString() + ":10002");
connect(retriever, SIGNAL(updatedBasestationLists()), this, SLOT(updateMapViewAccordingToBasestationModel())); //Bit of a race condition
}

}

/**
This function makes/destroys/updates points of interest on the map to ensure that they reflect what is stored in the base station data model.
*/
void transceiverGUI::updateMapViewAccordingToBasestationModel()
{
GeoDataTreeModel &mapTreeModel = *mapWidget->model()->treeModel();

//Lock mutex
std::lock_guard<std::mutex> lockGuard(visibleBasestationMutex);

//Construct a set of the IDs of all basestations in the visible region

//Find set basestations with acceptable latitudes, then the set with acceptable longitudes and then intersect the two sets
auto acceptableLatitudesStart = latitudeToBasestationKey.lower_bound(fmin(currentMapBoundaries[1], currentMapBoundaries[3]));
auto acceptableLatitudesEnd = latitudeToBasestationKey.upper_bound(fmax(currentMapBoundaries[1], currentMapBoundaries[3]));
std::vector<std::pair<int64_t, int64_t> > acceptableLatitudes;
for(auto iter = acceptableLatitudesStart; iter != acceptableLatitudesEnd; iter++)
{
acceptableLatitudes.push_back(iter->second);
}

auto acceptableLongitudesStart = longitudeToBasestationKey.lower_bound(fmin(currentMapBoundaries[0], currentMapBoundaries[2]));
auto acceptableLongitudesEnd = longitudeToBasestationKey.upper_bound(fmax(currentMapBoundaries[0], currentMapBoundaries[2]));

std::vector<std::pair<int64_t, int64_t> > acceptableLongitudes;
for(auto iter = acceptableLongitudesStart; iter != acceptableLongitudesEnd; iter++)
{
acceptableLongitudes.push_back(iter->second);
}

lastSetOfVisibleBasestations.clear();
std::set_intersection(acceptableLatitudes.begin(), acceptableLatitudes.end(), acceptableLongitudes.begin(), acceptableLongitudes.end(), std::inserter(lastSetOfVisibleBasestations, lastSetOfVisibleBasestations.begin()));

printf("Results size: %ld\n", lastSetOfVisibleBasestations.size());

//Remove any not visible basestations
for(auto iter = basestationIDToMapPlacemark.begin(); iter !=  basestationIDToMapPlacemark.end();)
{
if(lastSetOfVisibleBasestations.count(iter->first) == 0)
{
auto iterToErase = iter;
iter++;
mapTreeModel.removeFeature(iterToErase->second.get());
basestationIDToMapPlacemark.erase(iterToErase->first);
printf("Erasing basestation\n");
}
else
{
iter++;
}
}

for(auto instance : lastSetOfVisibleBasestations)
{
base_station_stream_information &basestation = potentiallyVisibleBasestationList.at(instance);

if(basestationIDToMapPlacemark.count(instance) == 1)
{//Update basestation
basestationIDToMapPlacemark.at(instance)->setCoordinate(basestation.latitude()*pylongps::PI/180.0, basestation.longitude()*pylongps::PI/180.0);
basestationIDToMapPlacemark.at(instance)->setName(QString(basestation.informal_name().c_str()));
printf("Updating basestation\n");
}
else
{//Add basestation
basestationIDToMapPlacemark.emplace(instance, std::move(std::unique_ptr<Marble::GeoDataPlacemark>(new GeoDataPlacemark(QString(basestation.informal_name().c_str())))));
basestationIDToMapPlacemark.at(instance)->setCoordinate(basestation.latitude()*pylongps::PI/180.0, basestation.longitude()*pylongps::PI/180.0);
mapTreeModel.addFeature(mapTreeModel.rootDocument(), basestationIDToMapPlacemark.at(instance).get());
printf("Adding basestation (Total: %ld)\n", basestationIDToMapPlacemark.size());
}

}

mapWidget->update(); //Trigger redraw
}
