#include "transceiverGUI.hpp"

using namespace pylongps;
using namespace Marble;

/**
This function initializes the class, connecting widgets, setting up the form generated by Qt designer and adding the components that the designer doesn't handle well.

@throw: This function can throw exceptions
*/
transceiverGUI::transceiverGUI()
{
setupUi(this);

SOM_TRY
context.reset(new zmq::context_t);
SOM_CATCH("Error, unable to make ZMQ context\n")

//Set buttons to switch the pages in the GUI
connect(toggleGUIPagePushButtonP1, SIGNAL(clicked(bool)), this, SLOT(toggleGUIPage()));
connect(toggleGUIPagePushButtonP2, SIGNAL(clicked(bool)), this, SLOT(toggleGUIPage()));

//Add a scrolly map without any other features
Marble::MarbleWidget *mapWidget = new Marble::MarbleWidget();
mapWidget->setProjection(Marble::Mercator);
mapWidget->setMapThemeId("earth/openstreetmap/openstreetmap.dgml");
mapWidget->setShowOverviewMap(false);
mapWidget->setShowCompass(false);
mapWidget->setShowScaleBar(false);
mapWidget->setShowCrosshairs(false);
mapWidget->setShowGrid(false);
mapWidget->centerOn(0.0,0.0);

//Hide navigator tool
QList<Marble::AbstractFloatItem *> floatItems = mapWidget->floatItems();
for(int i=0; i<floatItems.size(); i++)
{
floatItems.at(i)->hide();
}

 
GeoDataPlacemark *place = new GeoDataPlacemark( "Bucharest" );
place->setCoordinate( 25.97, 44.43, 0.0, GeoDataCoordinates::Degree );
place->setPopulation( 1877155 );
place->setCountryCode ( "Romania" );
  
GeoDataDocument *document = new GeoDataDocument;
document->append( place );
mapWidget->model()->treeModel()->addDocument( document );


baseStationMapLayout->addWidget(mapWidget);

mapWidget->setDistance(15);

//Create thread to redirect map/update basestations based on the lat/lon retrieved for the current IP
QThread *thread = new QThread;
IPBasedLocationRetriever *retriever = new IPBasedLocationRetriever;
retriever->moveToThread(thread);
connect(thread, SIGNAL(started()), retriever, SLOT(operate()));
connect(retriever, SIGNAL(finished()), thread, SLOT(quit()));
connect(retriever, SIGNAL(finished()), thread, SLOT(deleteLater()));
connect(thread, SIGNAL(finished()), thread, SLOT(deleteLater()));
connect(retriever, SIGNAL(retrievedLongitudeLatitude(double, double)), mapWidget, SLOT(centerOn(double, double)));
thread->start();

connect(mapWidget, SIGNAL(visibleLatLonAltBoxChanged(const GeoDataLatLonAltBox &)), this, SLOT(regionChanged(const GeoDataLatLonAltBox &)));

/*
//Create thread to redirect map/update basestations based on the lat/lon retrieved for the given address
QThread *thread = new QThread;
addressBasedLocationRetriever *addressRetriever = new addressBasedLocationRetriever("2043 Elizabeth Ave, Winston Salem NC 27103");
addressRetriever->moveToThread(thread);
connect(thread, SIGNAL(started()), addressRetriever, SLOT(operate()));
connect(addressRetriever, SIGNAL(finished()), thread, SLOT(quit()));
connect(addressRetriever, SIGNAL(finished()), thread, SLOT(deleteLater()));
connect(thread, SIGNAL(finished()), thread, SLOT(deleteLater()));
connect(addressRetriever, SIGNAL(retrievedLongitudeLatitude(double, double)), mapWidget, SLOT(centerOn(double, double)));
thread->start();
*/
} 

/**
This function toggles which page is displayed in the GUI.  If the current index is 0, it makes it 1 and vice versa.
*/
void transceiverGUI::toggleGUIPage()
{
if(mainWindowStackedWidget->count() > 1)
{ //Toggle the index
mainWindowStackedWidget->setCurrentIndex(!mainWindowStackedWidget->currentIndex());
}
}

/**
This function updates the visible basestation list and emits the visibleBasestationListChanged signal if the list changes.
@param inputVisibleRegion: A structure defining where on the earth is currently visible in the screen
*/
void transceiverGUI::regionChanged(const GeoDataLatLonAltBox &inputVisibleRegion)
{
printf("Region changed: %lf %lf %lf %lf\n", inputVisibleRegion.west()*180.0/pylongps::PI, inputVisibleRegion.north()*180.0/pylongps::PI, inputVisibleRegion.east()*180.0/pylongps::PI, inputVisibleRegion.south()*180.0/pylongps::PI);


std::array<double, 4> boundaries;
bool cacheExpired = false;
{
//Lock mutex
std::lock_guard<std::mutex> lockGuard(visibleBasestationMutex);

if(
((fmax(inputVisibleRegion.west(), inputVisibleRegion.east()) > fmax(lastQueryBoundaryInRadians[0], lastQueryBoundaryInRadians[2]) ||
fmin(inputVisibleRegion.west(), inputVisibleRegion.east()) > fmin(lastQueryBoundaryInRadians[0], lastQueryBoundaryInRadians[2]) ||
fmax(inputVisibleRegion.north(), inputVisibleRegion.south()) > fmax(lastQueryBoundaryInRadians[1], lastQueryBoundaryInRadians[3]) ||
fmin(inputVisibleRegion.north(), inputVisibleRegion.south()) > fmin(lastQueryBoundaryInRadians[1], lastQueryBoundaryInRadians[3]) || ((timeOfLastQueryUpdate + TRANSCEIVER_GUI_EXPIRATION_TIME) > Poco::Timestamp())) && 
(timeOfLastSentQuery + TRANSCEIVER_GUI_MINIMUM_TIME_BETWEEN_QUERIES) < Poco::Timestamp() )
)
{
printf("Time of last sent query: %ld %ld %d\n", (timeOfLastQueryUpdate + TRANSCEIVER_GUI_EXPIRATION_TIME).elapsed(), Poco::Timestamp().elapsed(), (timeOfLastSentQuery + TRANSCEIVER_GUI_MINIMUM_TIME_BETWEEN_QUERIES) < Poco::Timestamp());
cacheExpired = true;
std::array<double, 4> boundaries = {inputVisibleRegion.west()*TRANSCEIVER_QUERY_CACHING_CONSTANT, inputVisibleRegion.north()*TRANSCEIVER_QUERY_CACHING_CONSTANT, inputVisibleRegion.east()*TRANSCEIVER_QUERY_CACHING_CONSTANT, inputVisibleRegion.south()*TRANSCEIVER_QUERY_CACHING_CONSTANT};
}
else
{
//Clear current tags and update the map widget to show the currently visible basestations (apply to widget bar too)
}


} //Mutex unlocked

if(cacheExpired)
{
//The cache is out of date or does not cover where we are currently looking, so spawn a thread to update it and then exit
Poco::Net::HostEntry host;

SOM_TRY
host = Poco::Net::DNS::hostByName("www.pylongps.com");
SOM_CATCH("Error, unable to resolve URL\n")

if(host.addresses().size() == 0)
{
return;
}

basestationListRetriever *retriever = new basestationListRetriever(*this, boundaries, "tcp://" + host.addresses()[0].toString() + ":10002");
}

}
