#include "transceiverGUI.hpp"

using namespace pylongps;
using namespace Marble;



/**
This function initializes the class, connecting widgets, setting up the form generated by Qt designer and adding the components that the designer doesn't handle well.

@throw: This function can throw exceptions
*/
transceiverGUI::transceiverGUI()
{
qRegisterMetaType<corrections_message_format>("corrections_message_format");
qRegisterMetaType<credentials>("credentials");
setupUi(this);

SOM_TRY
context.reset(new zmq::context_t);
SOM_CATCH("Error, unable to make ZMQ context\n")

SOM_TRY
receiverSender.reset(new transceiver(*context));
SOM_CATCH("Error, unable to initialize tranceiver\n")

//Update caster IP string
Poco::Net::HostEntry host;
SOM_TRY
host = Poco::Net::DNS::hostByName("www.pylongps.com");
SOM_CATCH("Error, unable to resolve URL\n")
if(host.addresses().size() == 0)
{
return;
}
casterIPString = host.addresses()[0].toString();

//Set time of last query sending/update in the past so a new query is triggered
timeOfLastSentQuery -= TRANSCEIVER_GUI_MINIMUM_TIME_BETWEEN_QUERIES*10;
timeOfLastQueryUpdate -= TRANSCEIVER_GUI_EXPIRATION_TIME*10;

//Set buttons to switch the pages in the GUI
connect(toggleGUIPagePushButtonP1, SIGNAL(clicked(bool)), this, SLOT(toggleGUIPage()));
connect(toggleGUIPagePushButtonP2, SIGNAL(clicked(bool)), this, SLOT(toggleGUIPage()));
connect(this, SIGNAL(dataReceiversUpdated()), this, SLOT(updateDataReceiversDisplay()));
connect(this, SIGNAL(dataSendersUpdated()), this, SLOT(updateDataSendersDisplay()));

//Add a scrolly map without any other features
mapWidget = new Marble::MarbleWidget();
mapWidget->setProjection(Marble::Mercator);
mapWidget->setMapThemeId("earth/openstreetmap/openstreetmap.dgml");
mapWidget->setShowOverviewMap(false);
mapWidget->setShowCompass(false);
mapWidget->setShowScaleBar(true);
mapWidget->setShowCrosshairs(false);
mapWidget->setShowGrid(false);
mapWidget->centerOn(0.0,0.0);
mapWidget->inputHandler()->setMouseButtonPopupEnabled(Qt::LeftButton, false); //Disable the placemark popup menus
mapWidget->inputHandler()->setMouseButtonPopupEnabled(Qt::RightButton, false);
mapWidget->inputHandler()->setInertialEarthRotationEnabled(false);

mapWidget->inputHandler()->setPositionSignalConnected(true);

connect(mapWidget->inputHandler(), SIGNAL(mouseClickScreenPosition (int, int)), this, SLOT(processMouseClickOnMap(int, int)));

connect(this, SIGNAL(basestationSelectedOnMap(std::pair<int64_t, int64_t>)), this, SLOT(expandMapSelectedBasestation(std::pair<int64_t, int64_t>)));

//Hide navigator tool
QList<Marble::AbstractFloatItem *> floatItems = mapWidget->floatItems();
for(int i=0; i<floatItems.size(); i++)
{
floatItems.at(i)->hide();
}


baseStationMapLayout->addWidget(mapWidget);

mapWidget->setDistance(20);

connect(mapWidget, SIGNAL(visibleLatLonAltBoxChanged(const GeoDataLatLonAltBox &)), this, SLOT(regionChanged(const GeoDataLatLonAltBox &)));

connect(mapWidget, SIGNAL(visibleLatLonAltBoxChanged(const GeoDataLatLonAltBox &)), this, SLOT(updateMapViewAccordingToBasestationModel()));

//Wire up finding location based on addresses
connect(addressSelectionLineEdit, SIGNAL(returnPressed()), this, SLOT(lookupAddressAndUpdateMap()));
connect(findAddressPushButton, SIGNAL(clicked(bool)), this, SLOT(lookupAddressAndUpdateMap()));


//Wire up updating views based on basestation data model
connect(this, SIGNAL(signalThatDataModelPotentiallyChanged()), this, SLOT(updateMapViewAccordingToBasestationModel()));
connect(this, SIGNAL(signalThatDataModelPotentiallyChanged()), this, SLOT(updateSelectableBasestationWidgetsAccordingToBasestationModel()));

//Create thread to redirect map/update basestations based on the lat/lon retrieved for the current IP
IPBasedLocationRetriever *retriever = new IPBasedLocationRetriever;
connect(retriever, SIGNAL(retrievedLongitudeLatitude(double, double)), mapWidget, SLOT(centerOn(double, double)));
connect(retriever, SIGNAL(retrievedLongitudeLatitude(double, double)), this, SLOT(emitDataModelPotentiallyChangedSignal()));
retriever->start();

connect(createNewSourcePushButton, SIGNAL(clicked(bool)), this, SLOT(createDataReceiverDialogWindowForDisplay()));

//Setup SVG widget to display connections between data receivers and senders
dataReceiverToDataSenderFrame->installEventFilter(this);
receiverSenderConnectionsSVGWidget.reset(new QSvgWidget);

QVBoxLayout *connectionsLayout = new QVBoxLayout;
connectionsLayout->addWidget(receiverSenderConnectionsSVGWidget.get());
connectionsLayout->setContentsMargins(0,0,0,0);

dataReceiverToDataSenderFrame->setLayout(connectionsLayout);

connect(saveSettingsPushButton, SIGNAL(clicked(bool)), this, SLOT(updateConnectionsDrawing()));

//Setup saving/retrieving configuration files
connect(saveSettingsPushButton, SIGNAL(clicked(bool)), this, SLOT(openSaveCurrentConfigurationDialogWindow()));

connect(loadSettingsPushButton, SIGNAL(clicked(bool)), this, SLOT(openLoadConfigurationDialogWindow()));


showMaximized();
} 

/**
This function adds a data receiver widget to be displayed, inserting it into all common data receiver maps and updating the related displays.  It also takes ownership of the widget.
@param inputDataReceiverConnectionString: The data receiver connection string associated with the data receiver
@param inputDataReceiverWidget: The data receiver widget to display/take ownership of
*/
void transceiverGUI::addDataReceiverWidgetToDisplay(const std::string &inputDataReceiverConnectionString, QWidget *inputDataReceiverWidget)
{
dataReceiverConnectionStringToOwningPointer.emplace(inputDataReceiverConnectionString, std::unique_ptr<QWidget>(inputDataReceiverWidget));
displayOrderToDataReceiverWidgetAddress.emplace(nextDataReceiverWidgetDisplayOrder, inputDataReceiverWidget);
dataReceiverConnectionStringToDisplayOrderForAssociatedSenders.emplace(inputDataReceiverConnectionString, nextDataReceiverWidgetDisplayOrder*MAX_NUMBER_OF_SENDERS_ADDED_TO_RECEIVER);

nextDataReceiverWidgetDisplayOrder--;
emit dataReceiversUpdated();
}

/**
This function adds a data sender widget to be displayed, inserting it into all common data sender maps and updating the related displays.  It also takes ownership of the widget.
@param inputDataReceiverConnectionString: The connection string for the receiver this sender is associated with
@param inputDataSenderIDString: The data sender ID associated with the data sender
@param inputDataSenderWidget: The data sender widget to display/take ownership of
*/
void transceiverGUI::addDataSenderWidgetToDisplay(const std::string &inputDataReceiverConnectionString, const std::string &inputDataSenderIDString, QWidget *inputDataSenderWidget)
{
dataSenderIDToOwningPointer.emplace(inputDataSenderIDString, std::unique_ptr<QWidget>(inputDataSenderWidget));
displayOrderToDataSenderWidgetAddress.emplace(dataReceiverConnectionStringToDisplayOrderForAssociatedSenders[inputDataReceiverConnectionString], inputDataSenderWidget);

dataReceiverConnectionStringToDisplayOrderForAssociatedSenders[inputDataReceiverConnectionString]--;
emit dataSendersUpdated();
}

/**
This function deletes the widget associated with this data receiver, cleans out all maps which use the data receiver connection string as their key and removes all data senders (and their widgets) which are connected to this data receiver.
@param inputDataReceiverConnectionString: The data receiver connection string associated with the data receiver
*/
void transceiverGUI::removeDataReceiverAndItsWidget(const std::string &inputDataReceiverConnectionString)
{
QWidget *widgetPointer =  dataReceiverConnectionStringToOwningPointer.at(inputDataReceiverConnectionString).get();
selectedDataReceiversFrameLayout->removeWidget(widgetPointer);
selectedDataReceiversFrameLayout2->removeWidget(widgetPointer);

for(auto instance : displayOrderToDataReceiverWidgetAddress)
{
if(instance.second == widgetPointer)
{ //Remove entry for widget to remove
displayOrderToDataReceiverWidgetAddress.erase(instance.first);
break;
}
}

dataReceiverConnectionStringToOwningPointer.erase(inputDataReceiverConnectionString);
receiverSender->removeDataReceiver(inputDataReceiverConnectionString);
fileDataReceiverConnectionStringToAssociatedFileName.erase(inputDataReceiverConnectionString);
tcpDataReceiverConnectionStringToServerIPAddressAndPort.erase(inputDataReceiverConnectionString);
zmqDataReceiverConnectionStringToZMQPubIPAddressAndPort.erase(inputDataReceiverConnectionString);
dataReceiverConnectionStringToDisplayOrderForAssociatedSenders.erase(inputDataReceiverConnectionString);

for(auto instance : selectedBasestationIDToAssociatedZMQDataReceiver)
{
if(instance.second == inputDataReceiverConnectionString)
{ //Remove entry for widget to remove
selectedBasestationIDToAssociatedZMQDataReceiver.erase(instance.first);
break;
}
}

while(true)
{
auto dataSenderEntry = dataReceiverConnectionStringToConnectedSenderIDs.find(inputDataReceiverConnectionString);
if(dataSenderEntry == dataReceiverConnectionStringToConnectedSenderIDs.end())
{//All associated data senders have been removed
break;
}

std::string buffer = dataSenderEntry->second;
removeDataSenderAndItsWidget(buffer);
}


}

/**
This function clears the data receivers/data senders from the application.
*/
void transceiverGUI::removeAllDataReceiversDataSendersAndAssociatedWidgets()
{
while(dataReceiverConnectionStringToOwningPointer.size() > 0)
{
std::string buffer = dataReceiverConnectionStringToOwningPointer.begin()->first;
removeDataReceiverAndItsWidget(buffer);
}

}

/**
This function deletes the widget associated with this data sender, cleans out all maps which use the data sender connection string as their key.
@param inputDataSenderIDString: The data sender ID string
*/
void transceiverGUI::removeDataSenderAndItsWidget(const std::string &inputDataSenderConnectionString)
{
if(dataSenderIDToOwningPointer.count(inputDataSenderConnectionString) == 0)
{
return;
}

QWidget *widgetPointer =  dataSenderIDToOwningPointer.at(inputDataSenderConnectionString).get();
dataSendersFrameLayout->removeWidget(widgetPointer);

for(auto instance : displayOrderToDataSenderWidgetAddress)
{
if(instance.second == widgetPointer)
{ //Remove entry for widget to remove
displayOrderToDataSenderWidgetAddress.erase(instance.first);
break;
}
}

for(auto iter = dataReceiverConnectionStringToConnectedSenderIDs.begin(); iter !=  dataReceiverConnectionStringToConnectedSenderIDs.end(); iter++)
{
if(iter->second == inputDataSenderConnectionString)
{ //Remove entry for widget to remove
dataReceiverConnectionStringToConnectedSenderIDs.erase(iter);
break;
}
}

dataSenderIDToOwningPointer.erase(inputDataSenderConnectionString);
receiverSender->removeDataSender(inputDataSenderConnectionString);

fileDataSenderIDStringToAssociatedPath.erase(inputDataSenderConnectionString);
tcpDataSenderIDStringToServerPort.erase(inputDataSenderConnectionString);
zmqDataSenderIDStringToZMQPubPort.erase(inputDataSenderConnectionString);
basestationDataSenderIDToDetails.erase(inputDataSenderConnectionString);
}


/**
This function toggles which page is displayed in the GUI.  If the current index is 0, it makes it 1 and vice versa.
*/
void transceiverGUI::toggleGUIPage()
{
if(mainWindowStackedWidget->count() > 1)
{ //Toggle the index
mainWindowStackedWidget->setCurrentIndex(!mainWindowStackedWidget->currentIndex());

emit dataReceiversUpdated();
emit dataSendersUpdated();

}
}

/**
This function updates the visible basestation list and emits the visibleBasestationListChanged signal if the list changes.
@param inputVisibleRegion: A structure defining where on the earth is currently visible in the screen
*/
void transceiverGUI::regionChanged(const GeoDataLatLonAltBox &inputVisibleRegion)
{
currentMapBoundaries = std::array<double, 4>{inputVisibleRegion.west(), inputVisibleRegion.north(), inputVisibleRegion.east(), inputVisibleRegion.south()};
mapCenter[0] = inputVisibleRegion.center().latitude();
mapCenter[1] = inputVisibleRegion.center().longitude();

std::array<double, 4> boundaries;
bool cacheExpired = false;
{
//Lock mutex
std::lock_guard<std::mutex> lockGuard(visibleBasestationMutex);

if(
((fmax(inputVisibleRegion.west(), inputVisibleRegion.east()) > fmax(lastQueryBoundaryInRadians[0], lastQueryBoundaryInRadians[2]) ||
fmin(inputVisibleRegion.west(), inputVisibleRegion.east()) > fmin(lastQueryBoundaryInRadians[0], lastQueryBoundaryInRadians[2]) ||
fmax(inputVisibleRegion.north(), inputVisibleRegion.south()) > fmax(lastQueryBoundaryInRadians[1], lastQueryBoundaryInRadians[3]) ||
fmin(inputVisibleRegion.north(), inputVisibleRegion.south()) > fmin(lastQueryBoundaryInRadians[1], lastQueryBoundaryInRadians[3]) || ((timeOfLastQueryUpdate + TRANSCEIVER_GUI_EXPIRATION_TIME) > Poco::Timestamp())) && 
(timeOfLastSentQuery + TRANSCEIVER_GUI_MINIMUM_TIME_BETWEEN_QUERIES) < Poco::Timestamp() ) ||
(tranceiverGUIStartTime + 5*TRANSCEIVER_GUI_MINIMUM_TIME_BETWEEN_QUERIES > Poco::Timestamp())
)
{//Need to send update request
cacheExpired = true;

std::array<double, 2> latitudeMinMax = 
{
fmin(inputVisibleRegion.north(), inputVisibleRegion.south()), 
fmax(inputVisibleRegion.north(), inputVisibleRegion.south())
};
std::array<double, 2> longitudeMinMax = 
{
fmin(inputVisibleRegion.west(), inputVisibleRegion.east()), 
fmax(inputVisibleRegion.west(), inputVisibleRegion.east())
};
std::array<double, 2> boxDimensions = 
{
latitudeMinMax[1] - latitudeMinMax[0],
longitudeMinMax[1] - longitudeMinMax[0]
};

//Extend with TRANSCEIVER_QUERY_CACHING_CONSTANT so area covered is bigger
boundaries = 
{
longitudeMinMax[0] - boxDimensions[1]*TRANSCEIVER_QUERY_CACHING_CONSTANT, latitudeMinMax[0] - boxDimensions[0]*TRANSCEIVER_QUERY_CACHING_CONSTANT, 
longitudeMinMax[1] + boxDimensions[1]*TRANSCEIVER_QUERY_CACHING_CONSTANT, 
latitudeMinMax[1] + boxDimensions[0]*TRANSCEIVER_QUERY_CACHING_CONSTANT
};
}

} //Mutex unlocked

//Clear current tags and update the map widget to show the currently visible basestations (apply to widget bar too)
emit emitDataModelPotentiallyChangedSignal();

if(cacheExpired)
{
//The cache is out of date or does not cover where we are currently looking, so spawn a thread to update it and then exit
Poco::Net::HostEntry host;

SOM_TRY
host = Poco::Net::DNS::hostByName("www.pylongps.com");
SOM_CATCH("Error, unable to resolve URL\n")

if(host.addresses().size() == 0)
{
return;
}
casterIPString = host.addresses()[0].toString();

basestationListRetriever *retriever = new basestationListRetriever(*this, boundaries, "tcp://" + host.addresses()[0].toString() + ":10002");
connect(retriever, SIGNAL(updatedBasestationLists()), this, SLOT(emitDataModelPotentiallyChangedSignal()));
retriever->start();
}

}

/**
This function opens up a dialog window to allow a new data sender to be added for a particular data receiver.
@param inputDataReceiverConnectionString: The connection string for the data receiver to forward the data from.
*/
void transceiverGUI::createDataSenderDialogWindowForDisplay(const std::string &inputDataReceiverConnectionString)
{
dataSenderDialogWindow dialog(inputDataReceiverConnectionString, this);
connect(&dialog, SIGNAL(createFileDataSender(std::string, std::string)), this, SLOT(addFileDataSender(const std::string &, const std::string &)));
connect(&dialog, SIGNAL(createTCPDataSender(std::string, int64_t)), this, SLOT(addTCPDataSender(const std::string &, int64_t)));
connect(&dialog, SIGNAL(createZMQDataSender(std::string, int64_t)), this, SLOT(addZMQDataSender(const std::string &, int64_t)));
connect(&dialog, SIGNAL(createBasestationDataSender(std::string, std::string, double, double, corrections_message_format, double, std::string, credentials, bool)), this, SLOT(addBasestationDataSender(const std::string &, const std::string &, double, double, corrections_message_format, double, std::string, credentials, bool)));


dialog.exec();
}

/**
This function creates a zmq data receiver and its associated GUI.
@param inputIPAddress: A string holding the IP address of the TCP server to connect to
@param inputPort: The port on the host the the ZMQ SUB port is listening to 
@return: The ZMQ connection string for the data receiver
*/
std::string transceiverGUI::addZMQDataReceiver(const std::string &inputIPAddress, int64_t inputPort)
{
std::string dataReceiverConnectionString;
try
{
//Make data receiver
SOM_TRY
dataReceiverConnectionString = receiverSender->createZMQPubDataReceiver(inputIPAddress + ":" + std::to_string(inputPort));
SOM_CATCH("Error, unable to create data receiver\n")

//Add to map
zmqDataReceiverConnectionStringToZMQPubIPAddressAndPort.emplace(dataReceiverConnectionString, std::pair<std::string, int64_t>(inputIPAddress, inputPort));

//Make associated widget
zmqDataReceiverWidget *widgetPointer = new zmqDataReceiverWidget(dataReceiverConnectionString, inputIPAddress, inputPort);
addDataReceiverWidgetToDisplay(dataReceiverConnectionString, widgetPointer);
connect(widgetPointer, SIGNAL(dataReceiverMinusButtonPressed(std::string)), this, SLOT(removeDataReceiverAndItsWidget(const std::string &)));
connect(widgetPointer, SIGNAL(dataReceiverPlusButtonPressed(std::string)), this, SLOT(createDataSenderDialogWindowForDisplay(const std::string &)));
connect(widgetPointer, SIGNAL(sizeChanged()), this, SLOT(updateConnectionsDrawing()));
connect(widgetPointer, SIGNAL(widgetMoved()), this, SLOT(updateConnectionsDrawing()));
}
catch(const std::exception &inputException)
{
}
return dataReceiverConnectionString;
}

/**
This function creates a tcp data receiver and its associated GUI.
@param inputIPAddress: A string holding the IP address of the TCP server to connect to
@param inputPort: The port on the host the the TCP server is listening to 
@return: The ZMQ connection string for the data receiver
*/
std::string transceiverGUI::addTCPDataReceiver(const std::string &inputIPAddress, int64_t inputPort)
{
std::string dataReceiverConnectionString;

try
{
//Make data receiver
SOM_TRY
dataReceiverConnectionString = receiverSender->createTCPDataReceiver(inputIPAddress + ":" + std::to_string(inputPort));
SOM_CATCH("Error, unable to create data receiver\n")

//Add to map
tcpDataReceiverConnectionStringToServerIPAddressAndPort.emplace(dataReceiverConnectionString, std::pair<std::string, int64_t>(inputIPAddress, inputPort));

//Make associated widget
tcpDataReceiverWidget *widgetPointer = new tcpDataReceiverWidget(dataReceiverConnectionString, inputIPAddress, inputPort);
addDataReceiverWidgetToDisplay(dataReceiverConnectionString, widgetPointer);
connect(widgetPointer, SIGNAL(dataReceiverMinusButtonPressed(std::string)), this, SLOT(removeDataReceiverAndItsWidget(const std::string &)));
connect(widgetPointer, SIGNAL(dataReceiverPlusButtonPressed(std::string)), this, SLOT(createDataSenderDialogWindowForDisplay(const std::string &)));
connect(widgetPointer, SIGNAL(sizeChanged()), this, SLOT(updateConnectionsDrawing()));
connect(widgetPointer, SIGNAL(widgetMoved()), this, SLOT(updateConnectionsDrawing()));
}
catch(const std::exception &inputException)
{
}

return dataReceiverConnectionString;
}

/**
This function creates a file data receiver and its associated GUI.
@param inputFilePath: The path to the file to receive from
@return: The ZMQ connection string for the data receiver
*/
std::string transceiverGUI::addFileDataReceiver(const std::string &inputFilePath)
{
std::string dataReceiverConnectionString;

try
{
//Make data receiver
SOM_TRY
dataReceiverConnectionString = receiverSender->createFileDataReceiver(dataReceiverConnectionString);
SOM_CATCH("Error, unable to create data receiver\n")

//Add to map
fileDataReceiverConnectionStringToAssociatedFileName.emplace(dataReceiverConnectionString, inputFilePath);

//Make associated widget
fileDataReceiverWidget *widgetPointer = new fileDataReceiverWidget(dataReceiverConnectionString, inputFilePath);
addDataReceiverWidgetToDisplay(dataReceiverConnectionString, widgetPointer);
connect(widgetPointer, SIGNAL(dataReceiverMinusButtonPressed(std::string)), this, SLOT(removeDataReceiverAndItsWidget(const std::string &)));
connect(widgetPointer, SIGNAL(dataReceiverPlusButtonPressed(std::string)), this, SLOT(createDataSenderDialogWindowForDisplay(const std::string &)));
connect(widgetPointer, SIGNAL(sizeChanged()), this, SLOT(updateConnectionsDrawing()));
connect(widgetPointer, SIGNAL(widgetMoved()), this, SLOT(updateConnectionsDrawing()));
}
catch(const std::exception &inputException)
{
}

return dataReceiverConnectionString;
}

/**
This function adds a basestation data receiver and its associated widget.
@param inputCasterID: The ID of the caster to receive from
@param inputStreamID: The ID of the stream from the caster
@param inputBasestationInfo: The details to populate the widget with
@return: The ZMQ connection string for the data receiver or blank on failure
*/
std::string transceiverGUI::addBasestationDataReceiver(int64_t inputCasterID, int64_t inputStreamID, const base_station_stream_information &inputBasestationInfo)
{
std::string dataReceiverConnectionString;
//Add to maps
try
{ 
//Make data receiver
std::pair<int64_t, int64_t> basestationID(inputCasterID, inputStreamID);

SOM_TRY
dataReceiverConnectionString = receiverSender->createPylonGPSV2DataReceiver(casterIPString + ":10003", inputCasterID, inputStreamID);
SOM_CATCH("Error, unable to create data receiver\n")
selectedBasestationIDToAssociatedZMQDataReceiver.emplace(basestationID, dataReceiverConnectionString);

//Make associated widget
casterBasestationDataReceiverWidget *widgetPointer = new casterBasestationDataReceiverWidget(basestationID, inputBasestationInfo, dataReceiverConnectionString);
addDataReceiverWidgetToDisplay(dataReceiverConnectionString, widgetPointer);

connect(widgetPointer, SIGNAL(dataReceiverWidgetClosed(std::pair<int64_t, int64_t>)), this, SLOT(shutDownBasestationDataReceiver(std::pair<int64_t, int64_t>)));
connect(widgetPointer, SIGNAL(basestationAddedAsSelectedDataSource(std::string)), this, SLOT(createDataSenderDialogWindowForDisplay(const std::string &)));
connect(widgetPointer, SIGNAL(sizeChanged()), this, SLOT(updateConnectionsDrawing()));
connect(widgetPointer, SIGNAL(widgetMoved()), this, SLOT(updateConnectionsDrawing()));
}
catch(const std::exception &inputException)
{
}

return dataReceiverConnectionString;
}

/**
This function creates a addressBasedLocationReceiver object and uses it to update the map so that it points to the address.
*/
void transceiverGUI::lookupAddressAndUpdateMap()
{
addressBasedLocationRetriever *retriever = new addressBasedLocationRetriever(addressSelectionLineEdit->text().toStdString());
connect(retriever, SIGNAL(retrievedLongitudeLatitude(double, double)), mapWidget, SLOT(centerOn(double, double)));
retriever->start();
}

/**
This function makes/destroys/updates points of interest on the map to ensure that they reflect what is stored in the base station data model.
*/
void transceiverGUI::updateMapViewAccordingToBasestationModel()
{
GeoDataTreeModel &mapTreeModel = *mapWidget->model()->treeModel();

//Lock mutex
std::lock_guard<std::mutex> lockGuard(visibleBasestationMutex);

//Construct a set of the IDs of all basestations in the visible region

//Find set basestations with acceptable latitudes, then the set with acceptable longitudes and then intersect the two sets
auto acceptableLatitudesStart = latitudeToBasestationKey.lower_bound(fmin(currentMapBoundaries[1], currentMapBoundaries[3]));
auto acceptableLatitudesEnd = latitudeToBasestationKey.upper_bound(fmax(currentMapBoundaries[1], currentMapBoundaries[3]));
std::vector<std::pair<int64_t, int64_t> > acceptableLatitudes;
for(auto iter = acceptableLatitudesStart; iter != acceptableLatitudesEnd; iter++)
{
acceptableLatitudes.push_back(iter->second);
}

auto acceptableLongitudesStart = longitudeToBasestationKey.lower_bound(fmin(currentMapBoundaries[0], currentMapBoundaries[2]));
auto acceptableLongitudesEnd = longitudeToBasestationKey.upper_bound(fmax(currentMapBoundaries[0], currentMapBoundaries[2]));

std::vector<std::pair<int64_t, int64_t> > acceptableLongitudes;
for(auto iter = acceptableLongitudesStart; iter != acceptableLongitudesEnd; iter++)
{
acceptableLongitudes.push_back(iter->second);
}

lastSetOfVisibleBasestations.clear();
std::set_intersection(acceptableLatitudes.begin(), acceptableLatitudes.end(), acceptableLongitudes.begin(), acceptableLongitudes.end(), std::inserter(lastSetOfVisibleBasestations, lastSetOfVisibleBasestations.begin()));

//Remove any not visible basestations
for(auto iter = basestationIDToMapPlacemark.begin(); iter !=  basestationIDToMapPlacemark.end();)
{
if(lastSetOfVisibleBasestations.count(iter->first) == 0)
{
auto iterToErase = iter;
iter++;
mapTreeModel.removeFeature(iterToErase->second.get());
mapPlacemarkToBasestationID.erase(iterToErase->second.get());
basestationIDToMapPlacemark.erase(iterToErase->first);
}
else
{
iter++;
}
}

for(auto instance : lastSetOfVisibleBasestations)
{
base_station_stream_information &basestation = potentiallyVisibleBasestationList.at(instance);

if(basestationIDToMapPlacemark.count(instance) == 1)
{//Update basestation
basestationIDToMapPlacemark.at(instance)->setCoordinate(basestation.longitude()*pylongps::PI/180.0, basestation.latitude()*pylongps::PI/180.0);
basestationIDToMapPlacemark.at(instance)->setName(QString(basestation.informal_name().c_str()));
}
else
{//Add basestation
GeoDataPlacemark *pointer = new GeoDataPlacemark(QString(basestation.informal_name().c_str()));
basestationIDToMapPlacemark.emplace(instance, std::move(std::unique_ptr<Marble::GeoDataPlacemark>(pointer)));
mapPlacemarkToBasestationID.emplace(pointer, instance);

basestationIDToMapPlacemark.at(instance)->setCoordinate(basestation.longitude()*pylongps::PI/180.0, basestation.latitude()*pylongps::PI/180.0);
mapTreeModel.addFeature(mapTreeModel.rootDocument(), basestationIDToMapPlacemark.at(instance).get());
}

}

mapWidget->update(); //Trigger redraw
}

/**
This function updates any widgets which are still in the model, adds any that are new and removes all widgets which are no longer in the model.
*/
void transceiverGUI::updateSelectableBasestationWidgetsAccordingToBasestationModel()
{

//Lock mutex
std::lock_guard<std::mutex> lockGuard(visibleBasestationMutex);

//Sort by distance
std::map<double, std::pair<int64_t, int64_t>> distanceFromMapCenterToBasestationID;
for(auto instance : potentiallyVisibleBasestationList)
{
distanceFromMapCenterToBasestationID.emplace(calculateGreatCircleDistance(instance.second.latitude()*pylongps::PI/180.0,instance.second.longitude()*pylongps::PI/180.0, mapCenter[0], mapCenter[1]), instance.first);
}

//Remove all widgets that are not in the current set
for(auto instance : selectableBasestationsWidgets)
{
if(potentiallyVisibleBasestationList.count(instance.first) == 0)
{
selectWidgetAreaLayout->removeWidget(instance.second);
delete instance.second;
selectableBasestationsWidgets.erase(instance.first);
}
}

//Update all of the ones that are already present
for(auto instance : selectableBasestationsWidgets)
{
instance.second->updateBasestation(potentiallyVisibleBasestationList.at(instance.first));
}

//Add all of the widgets which are not already present
for(auto instance : distanceFromMapCenterToBasestationID)
{//baseStationSelectionScrollArea
if(selectableBasestationsWidgets.count(instance.second) == 0)
{//baseStationSelectionScrollArea takes ownership
casterBasestationWidget *widgetPointer = new casterBasestationWidget(instance.second, potentiallyVisibleBasestationList.at(instance.second), nullptr);
selectableBasestationsWidgets.emplace(instance.second, widgetPointer);

//Wire up adding data receiver when a basestation widget has the + button pressed
connect(widgetPointer, SIGNAL(basestationAddedAsSelectedDataSource(std::pair<int64_t, int64_t>)), this, SLOT(addBasestationAsDataSource(std::pair<int64_t, int64_t>)));
}
}

//Set distance for each basestation
for(auto instance : distanceFromMapCenterToBasestationID)
{
selectableBasestationsWidgets.at(instance.second)->setDistanceLabel(instance.first);
}

//Get set of all widgets
std::set<casterBasestationWidget*> widgets;
for(auto instance : selectableBasestationsWidgets)
{
widgets.insert(instance.second);
}

//Sort widgets according to distance
//Remove all widgets from layout
while(widgets.count((casterBasestationWidget*) selectWidgetAreaLayout->itemAt(0)) > 0)
{
selectWidgetAreaLayout->removeWidget((casterBasestationWidget*) selectWidgetAreaLayout->itemAt(0));
}

//Add them back in in order
int i=0;
for(auto instance : distanceFromMapCenterToBasestationID)
{
selectWidgetAreaLayout->insertWidget(i,selectableBasestationsWidgets.at(instance.second));
i++;
}

baseStationSelectionScrollArea->update();
}

/**
This function just emits the signalThatDataModelPotentiallyChanged signal.
*/
void transceiverGUI::emitDataModelPotentiallyChangedSignal()
{
emit signalThatDataModelPotentiallyChanged();
}

/**
This function takes the coordinates of a mouse click on the map and emits basestationSelectedOnMap signals for any basestations that would be selected by that click.
@param inputMouseClickX: The X coordinate of the mouse click on the map
@param inputMouseClickY: The Y coordinate of the mouse click on the map
*/
void transceiverGUI::processMouseClickOnMap(int inputMouseClickX, int inputMouseClickY)
{
QVector<const Marble::GeoDataFeature *> selectedPlacemarks = mapWidget->whichFeatureAt(QPoint(inputMouseClickX, inputMouseClickY));

for(const Marble::GeoDataFeature *selectedPlacemark : selectedPlacemarks)
{
if(mapPlacemarkToBasestationID.count((Marble::GeoDataPlacemark*) selectedPlacemark) > 0)
{
emit basestationSelectedOnMap(mapPlacemarkToBasestationID.at((Marble::GeoDataPlacemark*) selectedPlacemark));
}
}
}


/**
This slot expands the widget associated with the basestation that was selected on the map.
@param inputMapSelectedBasestationID: The ID the basestation whose widget to expand
*/
void transceiverGUI::expandMapSelectedBasestation(std::pair<int64_t, int64_t> inputMapSelectedBasestationID)
{
//Make widgets minimize with for loop TODO 
for(auto instance : selectableBasestationsWidgets)
{
instance.second->makeDetailsDisappear();
}


if(selectableBasestationsWidgets.count(inputMapSelectedBasestationID) > 0)
{
selectableBasestationsWidgets.at(inputMapSelectedBasestationID)->makeDetailsAppear();
}
}

/**
This function creates a dataReceiver for the given basestation and makes the associated widget.
@return: The ZMQ connection string for the data receiver
*/
std::string transceiverGUI::addBasestationAsDataSource(std::pair<int64_t, int64_t> inputWidgetSelectedBasestationID)
{
if(selectableBasestationsWidgets.count(inputWidgetSelectedBasestationID) == 0 || selectedBasestationIDToAssociatedZMQDataReceiver.count(inputWidgetSelectedBasestationID) > 0)
{//Station not found or we already have a receiver for it
return std::string();
}

return addBasestationDataReceiver(inputWidgetSelectedBasestationID.first, inputWidgetSelectedBasestationID.second, selectableBasestationsWidgets.at(inputWidgetSelectedBasestationID)->basestation);
}

/**
This function intercepts events that happen to the frame (including mouse hover) and emits the appropriate signals.
@param inputObject: The object that prompted the event signal
@param inputEvent: The event signal
*/
bool transceiverGUI::eventFilter(QObject *inputObject, QEvent *inputEvent)
{
if(inputObject == dataReceiverToDataSenderFrame && inputEvent->type() == QEvent::Resize)
{
updateConnectionsDrawing();
}

return QObject::eventFilter(inputObject, inputEvent);
}

/**
This function updates the display of widgets associated with data receivers, according to the current page and the displayOrderToDataReceiverWidgetAddress map.
*/
void transceiverGUI::updateDataReceiversDisplay()
{
//Move the selected data receivers so that they show in the other page
if(mainWindowStackedWidget->currentIndex() == 0)
{
for(auto instance : displayOrderToDataReceiverWidgetAddress)
{
selectedDataReceiversFrameLayout2->removeWidget(instance.second);
selectedDataReceiversFrameLayout->insertWidget(0, instance.second);//Make first in layout
}
}
else
{
for(auto instance : displayOrderToDataReceiverWidgetAddress)
{
selectedDataReceiversFrameLayout->removeWidget(instance.second);
selectedDataReceiversFrameLayout2->insertWidget(0, instance.second);//Make first in layout
}
}
}

/**
This function updates the display of widgets associated with data senders according to the displayOrderToDataSenderWidgetAddress map.  Emits updatedDataSendersDisplay() signal when completed.
*/
void transceiverGUI::updateDataSendersDisplay()
{
for(auto instance : displayOrderToDataSenderWidgetAddress)
{
dataSendersFrameLayout->removeWidget(instance.second);
}

for(auto instance : displayOrderToDataSenderWidgetAddress)
{
dataSendersFrameLayout->insertWidget(0, instance.second);//Make first in layout
}

emit updatedDataSendersDisplay();
}

/**
This function removes the data receiver associated with the given casterID/basestationID pair.
@param inputBasestationID: The casterID/basestationID pair
*/
void transceiverGUI::shutDownBasestationDataReceiver(std::pair<int64_t, int64_t> inputBasestationID)
{

if(selectedBasestationIDToAssociatedZMQDataReceiver.count(inputBasestationID) == 0)
{
return;
}

std::string &dataReceiverConnectionString = selectedBasestationIDToAssociatedZMQDataReceiver.at(inputBasestationID);

removeDataReceiverAndItsWidget(dataReceiverConnectionString);
selectedBasestationIDToAssociatedZMQDataReceiver.erase(inputBasestationID);

}

/**
This function creates a dialog window and connects it so that it can be used to create a new data receiver (which is displayed in the main GUI).
*/
void transceiverGUI::createDataReceiverDialogWindowForDisplay()
{
createDataReceiverDialogWindow dialog(this);
connect(&dialog, SIGNAL(createFileDataReader(std::string)), this, SLOT(addFileDataReceiver(const std::string &)));
connect(&dialog, SIGNAL(createTCPDataReader(std::string, int64_t)), this, SLOT(addTCPDataReceiver(const std::string &, int64_t)));
connect(&dialog, SIGNAL(createZMQDataReader(std::string, int64_t)), this, SLOT(addZMQDataReceiver(const std::string &, int64_t)));

dialog.exec();
}

/**
This slot opens a dialog window to select where to save the settings file to and then calls saveCurrentConfiguration with the returned path.
*/
void transceiverGUI::openSaveCurrentConfigurationDialogWindow()
{
//Open file dialog
QString qPath = QFileDialog::getSaveFileName(this, "Save Configuration", QString(configurationFilePath.c_str()), ("Tranceiver Configuration File (*" + TRANSCEIVER_CONFIGURATION_FILE_EXTENSION+")").c_str());
std::string path = qPath.toStdString();
if(path.size() > 0)
{
configurationFilePath = path;
saveCurrentConfiguration(configurationFilePath);
}

}

/**
This function saves the current configuration of the transceiver to a file so that it can be reconstructed later either with the GUI or a command line program.
@param inputPathToSaveTo: Where to save the configuration file
*/
void transceiverGUI::saveCurrentConfiguration(const std::string &inputPathToSaveTo)
{
std::map<std::string, int64_t> dataReceiverConnectionStringToSerializedDataReceiverID;
int64_t uniqueSerializedDataReceiverID = 0;

std::set<int64_t> storedDataReceivers; //The list of data receivers that have been serialized

for(auto iter = dataReceiverConnectionStringToOwningPointer.begin(); iter != dataReceiverConnectionStringToOwningPointer.end(); iter++)
{ //Make IDs
dataReceiverConnectionStringToSerializedDataReceiverID.emplace(iter->first, uniqueSerializedDataReceiverID);
uniqueSerializedDataReceiverID++;
}

transceiver_configuration configuration;

for(auto instance : selectedBasestationIDToAssociatedZMQDataReceiver)
{ //Store basestation data receivers
if(dataReceiverConnectionStringToSerializedDataReceiverID.count(instance.second) == 0)
{//Don't have that one, so skip
continue;
}

basestation_data_receiver_configuration *baseStationDataReceiver = configuration.add_basestation_receivers();

baseStationDataReceiver->set_receiver_id(dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.second));
baseStationDataReceiver->set_caster_id(instance.first.first);
baseStationDataReceiver->set_stream_id(instance.first.second);

if(dataReceiverConnectionStringToOwningPointer.count(instance.second) > 0)
{
casterBasestationDataReceiverWidget &associatedWidget = *((casterBasestationDataReceiverWidget *) dataReceiverConnectionStringToOwningPointer.at(instance.second).get());
(*baseStationDataReceiver->mutable_basestation_details()) =  associatedWidget.basestation;
}

storedDataReceivers.insert(dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.second));
}


for(auto instance : fileDataReceiverConnectionStringToAssociatedFileName)
{ //Store file data receivers
if(dataReceiverConnectionStringToSerializedDataReceiverID.count(instance.first) == 0)
{//Don't have that one, so skip
continue;
}

file_data_receiver_configuration *fileDataReceiver = configuration.add_file_receivers();

fileDataReceiver->set_receiver_id(dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.first));
fileDataReceiver->set_file_path(instance.second);

storedDataReceivers.insert(dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.first));
}

for(auto instance : tcpDataReceiverConnectionStringToServerIPAddressAndPort)
{ //Store file data receivers
if(dataReceiverConnectionStringToSerializedDataReceiverID.count(instance.first) == 0)
{//Don't have that one, so skip
continue;
}

tcp_data_receiver_configuration *dataReceiver = configuration.add_tcp_receivers();

dataReceiver->set_receiver_id(dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.first));
dataReceiver->set_server_ip_address(instance.second.first);
dataReceiver->set_server_port(instance.second.second);

storedDataReceivers.insert(dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.first));
}

for(auto instance : zmqDataReceiverConnectionStringToZMQPubIPAddressAndPort)
{ //Store zmq receivers
if(dataReceiverConnectionStringToSerializedDataReceiverID.count(instance.first) == 0)
{//Don't have that one, so skip
continue;
}

zmq_data_receiver_configuration *dataReceiver = configuration.add_zmq_receivers();

dataReceiver->set_receiver_id(dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.first));
dataReceiver->set_server_ip_address(instance.second.first);
dataReceiver->set_server_port(instance.second.second);

storedDataReceivers.insert(dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.first));
}

//All receivers have been added, so add senders
for(const std::pair<std::string, std::string> &instance : dataReceiverConnectionStringToConnectedSenderIDs)
{
if(dataReceiverConnectionStringToSerializedDataReceiverID.count(instance.first) == 0)
{//Couldn't find data receiver in list of IDs
continue;
}

int64_t receiverID = dataReceiverConnectionStringToSerializedDataReceiverID.at(instance.first);



if(fileDataSenderIDStringToAssociatedPath.count(instance.second) > 0)
{//Its a file data sender
file_data_sender_configuration *dataSender = configuration.add_file_senders();

dataSender->set_receiver_id(receiverID);
(*dataSender->mutable_file_path_to_write_to()) = fileDataSenderIDStringToAssociatedPath.at(instance.second);
continue;
}

if(tcpDataSenderIDStringToServerPort.count(instance.second) > 0)
{//Its a tcp data sender
tcp_data_sender_configuration *dataSender = configuration.add_tcp_senders();

dataSender->set_receiver_id(receiverID);
dataSender->set_server_port(tcpDataSenderIDStringToServerPort.at(instance.second));
continue;
}

if(zmqDataSenderIDStringToZMQPubPort.count(instance.second) > 0)
{//Its a zmq data sender
zmq_data_sender_configuration *dataSender = configuration.add_zmq_senders();

dataSender->set_receiver_id(receiverID);
dataSender->set_server_port(zmqDataSenderIDStringToZMQPubPort.at(instance.second));
continue;
}

if(basestationDataSenderIDToDetails.count(instance.second) > 0)
{//Its a basestation data sender
basestation_data_sender_configuration *dataSender = configuration.add_basestation_senders();


double latitude = 0.0;
double longitude = 0.0;
corrections_message_format message_format;
std::string informal_basestation_name;
double expected_update_rate = 0.0; 
std::string secret_key;
credentials registration_credentials;
bool credentialsValid = false;

std::tie(informal_basestation_name, latitude, longitude, message_format, expected_update_rate, secret_key, registration_credentials, credentialsValid) = basestationDataSenderIDToDetails.at(instance.second);

dataSender->set_receiver_id(receiverID);
(*dataSender->mutable_caster_ip_address()) = casterIPString;
dataSender->set_caster_registration_port(PORT_NUMBER_FOR_BASESTATION_REGISTRATION);
dataSender->set_latitude(latitude);
dataSender->set_longitude(longitude);
dataSender->set_message_format(message_format);
(*dataSender->mutable_informal_basestation_name()) = informal_basestation_name;
dataSender->set_expected_update_rate(expected_update_rate);

if(secret_key.size() > 0 && credentialsValid)
{
(*dataSender->mutable_secret_key()) = secret_key;
(*dataSender->mutable_registration_credentials()) = registration_credentials;
}
continue;
}

}

if(inputPathToSaveTo.compare(inputPathToSaveTo.length() - TRANSCEIVER_CONFIGURATION_FILE_EXTENSION.length(), TRANSCEIVER_CONFIGURATION_FILE_EXTENSION.length(), TRANSCEIVER_CONFIGURATION_FILE_EXTENSION) == 0)
{
saveProtobufObjectToFile(inputPathToSaveTo, configuration);
}
else
{
saveProtobufObjectToFile(inputPathToSaveTo + TRANSCEIVER_CONFIGURATION_FILE_EXTENSION, configuration);
}
}

/**
This function opens a dialog window to select a configuration file to load and then calls loadConfiguration with the selected path.
*/
void transceiverGUI::openLoadConfigurationDialogWindow()
{
QString qPath = QFileDialog::getOpenFileName(this, "Open Transceiver Configuration File", QString(configurationFilePath.c_str()),  ("Tranceiver Configuration File (*" + TRANSCEIVER_CONFIGURATION_FILE_EXTENSION+")").c_str());

std::string path = qPath.toStdString();
if(path.size() == 0)
{
return;
}

configurationFilePath = path;
loadConfiguration(configurationFilePath);
}

/**
This function clears the current settings, reads a transceiver configuration file and applies the settings to this transceiver.
@param inputPathToReadFrom: The path to read from
*/
void transceiverGUI::loadConfiguration(const std::string &inputPathToReadFrom)
{

transceiver_configuration configuration;

if(!loadProtobufObjectFromFile(inputPathToReadFrom, configuration))
{//Unable to load configuration
return;
}

//Clear current data receivers/senders
removeAllDataReceiversDataSendersAndAssociatedWidgets();

std::map<int64_t, std::string> receiverIDToConnectionString;

for(int i=0; i<configuration.basestation_receivers_size(); i++)
{ //Load basestation receiver
const basestation_data_receiver_configuration &dataReceiverConfiguration = configuration.basestation_receivers(i);

if(receiverIDToConnectionString.count(dataReceiverConfiguration.receiver_id()) != 0 || !dataReceiverConfiguration.has_basestation_details())
{ //Skip receiver if one with the same ID has already been loaded or we don't have details to display
continue;
}

std::string connectionString = addBasestationDataReceiver(dataReceiverConfiguration.caster_id(), dataReceiverConfiguration.stream_id(), dataReceiverConfiguration.basestation_details());
if(connectionString.size() == 0)
{
continue;
}

receiverIDToConnectionString[dataReceiverConfiguration.receiver_id()] = connectionString;
}

for(int i=0; i<configuration.file_receivers_size(); i++)
{ //Load file receiver
const file_data_receiver_configuration &dataReceiverConfiguration = configuration.file_receivers(i);

if(receiverIDToConnectionString.count(dataReceiverConfiguration.receiver_id()) != 0)
{ //Skip receiver if one with the same ID has already been loaded
continue;
}

std::string connectionString = addFileDataReceiver(dataReceiverConfiguration.file_path());
if(connectionString.size() == 0)
{
continue;
}

receiverIDToConnectionString[dataReceiverConfiguration.receiver_id()] = connectionString;
}

for(int i=0; i<configuration.tcp_receivers_size(); i++)
{ //Load tcp receiver
const tcp_data_receiver_configuration &dataReceiverConfiguration = configuration.tcp_receivers(i);

if(receiverIDToConnectionString.count(dataReceiverConfiguration.receiver_id()) != 0)
{ //Skip receiver if one with the same ID has already been loaded
continue;
}

std::string connectionString = addTCPDataReceiver(dataReceiverConfiguration.server_ip_address(), dataReceiverConfiguration.server_port());
if(connectionString.size() == 0)
{
continue;
}

receiverIDToConnectionString[dataReceiverConfiguration.receiver_id()] = connectionString;
}

for(int i=0; i<configuration.zmq_receivers_size(); i++)
{ //Load zmq receiver
const zmq_data_receiver_configuration &dataReceiverConfiguration = configuration.zmq_receivers(i);

if(receiverIDToConnectionString.count(dataReceiverConfiguration.receiver_id()) != 0)
{ //Skip receiver if one with the same ID has already been loaded
continue;
}

std::string connectionString = addZMQDataReceiver(dataReceiverConfiguration.server_ip_address(), dataReceiverConfiguration.server_port());
if(connectionString.size() == 0)
{
continue;
}

receiverIDToConnectionString[dataReceiverConfiguration.receiver_id()] = connectionString;
}

//Add data senders
for(int i=0; i<configuration.basestation_senders_size(); i++)
{ //Load basestation sender
const basestation_data_sender_configuration &dataSenderConfiguration = configuration.basestation_senders(i);

if(receiverIDToConnectionString.count(dataSenderConfiguration.receiver_id()) == 0)
{ //Skip sender if the associated receiver hasn't been loaded
continue;
}

const std::string &receiverConnectionString = receiverIDToConnectionString.at(dataSenderConfiguration.receiver_id());

addBasestationDataSender(receiverConnectionString, dataSenderConfiguration.informal_basestation_name(), dataSenderConfiguration.latitude(), dataSenderConfiguration.longitude(), dataSenderConfiguration.message_format(), dataSenderConfiguration.expected_update_rate(), dataSenderConfiguration.secret_key(), dataSenderConfiguration.registration_credentials(), dataSenderConfiguration.has_registration_credentials());
}

for(int i=0; i<configuration.file_senders_size(); i++)
{ //Load file sender
const file_data_sender_configuration &dataSenderConfiguration = configuration.file_senders(i);

if(receiverIDToConnectionString.count(dataSenderConfiguration.receiver_id()) == 0)
{ //Skip sender if the associated receiver hasn't been loaded
continue;
}

const std::string &receiverConnectionString = receiverIDToConnectionString.at(dataSenderConfiguration.receiver_id());

addFileDataSender(receiverConnectionString, dataSenderConfiguration.file_path_to_write_to());
}

for(int i=0; i<configuration.tcp_senders_size(); i++)
{ //Load tcp sender
const tcp_data_sender_configuration &dataSenderConfiguration = configuration.tcp_senders(i);

if(receiverIDToConnectionString.count(dataSenderConfiguration.receiver_id()) == 0)
{ //Skip sender if the associated receiver hasn't been loaded
continue;
}

const std::string &receiverConnectionString = receiverIDToConnectionString.at(dataSenderConfiguration.receiver_id());

addTCPDataSender(receiverConnectionString, dataSenderConfiguration.server_port());
}

for(int i=0; i<configuration.zmq_senders_size(); i++)
{ //Load zmq sender
const zmq_data_sender_configuration &dataSenderConfiguration = configuration.zmq_senders(i);

if(receiverIDToConnectionString.count(dataSenderConfiguration.receiver_id()) == 0)
{ //Skip sender if the associated receiver hasn't been loaded
continue;
}

const std::string &receiverConnectionString = receiverIDToConnectionString.at(dataSenderConfiguration.receiver_id());

addZMQDataSender(receiverConnectionString, dataSenderConfiguration.server_port());
}
}


/**
This function updates the SVG widget to draw lines pointing from a data receiver to its associated data sender.
*/
void transceiverGUI::updateConnectionsDrawing()
{
QPoint frameDimensions = QPoint(dataReceiverToDataSenderFrame->width(), dataReceiverToDataSenderFrame->height());

std::string svgToDraw = "<svg width=\"" + std::to_string(frameDimensions.x()) + "\" height=\"" + std::to_string(frameDimensions.y()) +  "\">\n";

//Generate connection pointer strings
for(auto receiverIter = dataReceiverConnectionStringToOwningPointer.begin(); receiverIter != dataReceiverConnectionStringToOwningPointer.end(); receiverIter++)
{
//QPoint receiverPosition = receiverIter->second->rect().center();
QPoint receiverPosition = receiverIter->second->pos()+QPoint(receiverIter->second->width()/2, receiverIter->second->height()/2);

//Pair of iterators for range associated with the key
auto relatedSenderIterators = dataReceiverConnectionStringToConnectedSenderIDs.equal_range(receiverIter->first);

for(auto iter = relatedSenderIterators.first; iter != relatedSenderIterators.second; iter++)
{
if(dataSenderIDToOwningPointer.count(iter->second) == 0)
{//Skip if the related widget isn't found
continue;
}

std::unique_ptr<QWidget> &senderWidgetOwningPointerReference = dataSenderIDToOwningPointer.at(iter->second);
QPoint senderPosition = senderWidgetOwningPointerReference->pos() + QPoint(senderWidgetOwningPointerReference->width()/2, senderWidgetOwningPointerReference->height()/2);


svgToDraw += std::string("<line x1=\"0\" y1=\"" +std::to_string(receiverPosition.y())+ "\" x2=\""+std::to_string(frameDimensions.x())+"\" y2=\""+std::to_string(senderPosition.y())+"\" style=\"stroke:rgb(0,0,0);stroke-width:2;\"/>\n");

}

}
svgToDraw += std::string("</svg>\n");

receiverSenderConnectionsSVGWidget->load(QByteArray(svgToDraw.c_str(), svgToDraw.size()));
}

/**
This function creates a basestation data sender and its associated GUI.
@param inputDataReceiverConnectionString: The connection string for the data receiver to forward from
@param inputInformalBasestationName: The informal name of the basestation
@param inputLatitude: The latitude that will be reported for the basestation
@param inputLongitude: The longitude that will be reported for the basestation
@param inputMessageFormat: The format of the messages are in
@param inputExpectedMessageRate: The expected sending rate of the messages
@param inputBasestationSecretKey: A secret key to use for an authenticated basestation (assumes unauthenticated if missing)
@param inputCredentials: The credentials to use with authentication (empty if not used)
@param inputCredentialsLoaded: True if the credentials should be valid
*/
void transceiverGUI::addBasestationDataSender(const std::string &inputDataReceiverConnectionString, const std::string &inputInformalBasestationName, double inputLatitude, double inputLongitude, corrections_message_format inputMessageFormat, double inputExpectedMessageRate, const std::string & inputBasestationSecretKey, credentials inputCredentials, bool inputCredentialsLoaded)
{
try
{
//Make data sender
std::string dataSenderIDString;

if(inputCredentialsLoaded == true && inputBasestationSecretKey.size()!=0)
{//Authenticated
SOM_TRY
dataSenderIDString = receiverSender->createPylonGPSV2DataSender(inputDataReceiverConnectionString, inputBasestationSecretKey, inputCredentials, casterIPString + ":" + std::to_string(PORT_NUMBER_FOR_BASESTATION_REGISTRATION), inputLatitude, inputLongitude, inputMessageFormat, inputInformalBasestationName, inputExpectedMessageRate);
SOM_CATCH("Error, unable to create data sender\n")
}
else
{//Unauthenticated
SOM_TRY
dataSenderIDString = receiverSender->createPylonGPSV2DataSender(inputDataReceiverConnectionString, casterIPString + ":" + std::to_string(PORT_NUMBER_FOR_BASESTATION_REGISTRATION), inputLatitude, inputLongitude, inputMessageFormat, inputInformalBasestationName, inputExpectedMessageRate);
SOM_CATCH("Error, unable to create data sender\n")
}


//Add to maps
dataReceiverConnectionStringToConnectedSenderIDs.emplace(inputDataReceiverConnectionString, dataSenderIDString);


basestationDataSenderIDToDetails.emplace(dataSenderIDString, std::tuple<std::string, double, double, corrections_message_format, double, std::string, credentials, bool>(inputInformalBasestationName, inputLatitude, inputLongitude, inputMessageFormat, inputExpectedMessageRate, inputBasestationSecretKey, inputCredentials, inputCredentialsLoaded));

//Make associated widget
basestationDataSenderWidget *widgetPointer = new basestationDataSenderWidget(dataSenderIDString, inputInformalBasestationName, inputLatitude, inputLongitude, inputMessageFormat, inputExpectedMessageRate);
addDataSenderWidgetToDisplay(inputDataReceiverConnectionString, dataSenderIDString, widgetPointer);


connect(widgetPointer, SIGNAL(dataSenderMinusButtonPressed(std::string)), this, SLOT(removeDataSenderAndItsWidget(const std::string &)));
connect(widgetPointer, SIGNAL(sizeChanged()), this, SLOT(updateConnectionsDrawing()));
connect(widgetPointer, SIGNAL(widgetMoved()), this, SLOT(updateConnectionsDrawing()));
}
catch(const std::exception &inputException)
{
}
}

/**
This function creates a zmq data sender and its associated GUI.
@param inputDataReceiverConnectionString: The connection string for the data receiver to forward from
@param inputPort: The port on the host the the ZMQ server is listening to 
*/
void transceiverGUI::addZMQDataSender(const std::string &inputDataReceiverConnectionString, int64_t inputPort)
{
try
{
//Make data sender
std::string dataSenderIDString;
SOM_TRY
dataSenderIDString = receiverSender->createZMQDataSender(inputDataReceiverConnectionString, inputPort);
SOM_CATCH("Error, unable to create data sender\n")

//Add to maps
dataReceiverConnectionStringToConnectedSenderIDs.emplace(inputDataReceiverConnectionString, dataSenderIDString);
zmqDataSenderIDStringToZMQPubPort.emplace(dataSenderIDString, inputPort);

//Make associated widget
zmqDataSenderWidget *widgetPointer = new zmqDataSenderWidget(dataSenderIDString, inputPort);
addDataSenderWidgetToDisplay(inputDataReceiverConnectionString, dataSenderIDString, widgetPointer);


connect(widgetPointer, SIGNAL(dataSenderMinusButtonPressed(std::string)), this, SLOT(removeDataSenderAndItsWidget(const std::string &)));
connect(widgetPointer, SIGNAL(sizeChanged()), this, SLOT(updateConnectionsDrawing()));
connect(widgetPointer, SIGNAL(widgetMoved()), this, SLOT(updateConnectionsDrawing()));
}
catch(const std::exception &inputException)
{
}
}

/**
This function creates a tcp data sender and its associated GUI.
@param inputDataReceiverConnectionString: The connection string for the data receiver to forward from
@param inputPort: The port on the host the the TCP server is listening to 
*/
void transceiverGUI::addTCPDataSender(const std::string &inputDataReceiverConnectionString, int64_t inputPort)
{
try
{
//Make data sender
std::string dataSenderIDString;
SOM_TRY
dataSenderIDString = receiverSender->createTCPDataSender(inputDataReceiverConnectionString, inputPort);
SOM_CATCH("Error, unable to create data sender\n")

//Add to maps
dataReceiverConnectionStringToConnectedSenderIDs.emplace(inputDataReceiverConnectionString, dataSenderIDString);
tcpDataSenderIDStringToServerPort.emplace(dataSenderIDString, inputPort);

//Make associated widget
tcpDataSenderWidget *widgetPointer = new tcpDataSenderWidget(dataSenderIDString, inputPort);
addDataSenderWidgetToDisplay(inputDataReceiverConnectionString, dataSenderIDString, widgetPointer);


connect(widgetPointer, SIGNAL(dataSenderMinusButtonPressed(std::string)), this, SLOT(removeDataSenderAndItsWidget(const std::string &)));
connect(widgetPointer, SIGNAL(sizeChanged()), this, SLOT(updateConnectionsDrawing()));
connect(widgetPointer, SIGNAL(widgetMoved()), this, SLOT(updateConnectionsDrawing()));
}
catch(const std::exception &inputException)
{
}

}

/**
This function creates a file data sender and its associated GUI.
@param inputDataReceiverConnectionString: The connection string for the data receiver to forward from
@param inputFilePath: The path to the file to send to
*/
void transceiverGUI::addFileDataSender(const std::string &inputDataReceiverConnectionString, const std::string &inputFilePath)
{
try
{
//Make data sender
std::string dataSenderIDString;
SOM_TRY
dataSenderIDString = receiverSender->createFileDataSender(inputDataReceiverConnectionString, inputFilePath);
SOM_CATCH("Error, unable to create data sender\n")

//Add to maps
dataReceiverConnectionStringToConnectedSenderIDs.emplace(inputDataReceiverConnectionString, dataSenderIDString);
fileDataSenderIDStringToAssociatedPath.emplace(dataSenderIDString, inputFilePath);

//Make associated widget
fileDataSenderWidget *widgetPointer = new fileDataSenderWidget(dataSenderIDString, inputFilePath);
addDataSenderWidgetToDisplay(inputDataReceiverConnectionString, dataSenderIDString, widgetPointer);

connect(widgetPointer, SIGNAL(dataSenderMinusButtonPressed(std::string)), this, SLOT(removeDataSenderAndItsWidget(const std::string &)));
connect(widgetPointer, SIGNAL(sizeChanged()), this, SLOT(updateConnectionsDrawing()));
connect(widgetPointer, SIGNAL(widgetMoved()), this, SLOT(updateConnectionsDrawing()));
}
catch(const std::exception &inputException)
{
}

}

