#include "casterGUI.hpp"

using namespace pylongps;

/**
This function initializes the class, connecting widgets, setting up the form generated by Qt designer and adding the components that the designer doesn't handle well.

@throw: This function can throw exceptions
*/
casterGUI::casterGUI()
{
setupUi(this);
casterConfigurationStackedWidget->setCurrentIndex(0);

//Setup page control buttons
connect(configurationPushButton, SIGNAL(clicked(bool)), this, SLOT(switchToConfigureCasterPage()));
connect(createCredentialsPushButton, SIGNAL(clicked(bool)), this, SLOT(switchToCreateCredentialsPage()));
connect(addRemoveKeysPushButton, SIGNAL(clicked(bool)), this, SLOT(switchToAddRemoveKeysPage()));

//Add key generation button functionality
connect(generateKeysPushButton, SIGNAL(clicked(bool)), this, SLOT(selectDirectoryForKeyPairGeneration()));
connect(this, SIGNAL(keyPairGenerationFolderSelected(std::string)), this, SLOT(generateKeyPairFiles(std::string)));

//Add validators to line edits
casterIDLineEdit->setValidator(new QIntValidator(0, INT_MAX, this));

int portNumberMax = 65535;
dataSenderPortNumberLineEdit->setValidator( new QIntValidator(0, portNumberMax, this) );
clientRequestPortNumberLineEdit->setValidator( new QIntValidator(0, portNumberMax, this) );
clientStreamPublishingPortNumberLineEdit->setValidator( new QIntValidator(0, portNumberMax, this) );
proxyStreamPublishingPortNumberLineEdit->setValidator( new QIntValidator(0, portNumberMax, this) );
streamStatusNotificationPortNumberLineEdit->setValidator( new QIntValidator(0, portNumberMax, this) );
keyManagementPortNumberLineEdit->setValidator( new QIntValidator(0, portNumberMax, this) );
casterPortLineEdit->setValidator( new QIntValidator(0, portNumberMax, this) );

selectCredentialsBasestationLimit->setValidator( new QIntValidator(0, INT_MAX, this) );

//Validate IP addresses
QRegExp IPAddressRegex("^0*([1-9]?\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.0*([1-9]?\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.0*([1-9]?\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.0*([1-9]?\\d|1\\d\\d|2[0-4]\\d|25[0-5])$");
casterIPAddressLineEdit->setValidator(new QRegExpValidator(IPAddressRegex, this));

//Set datetimes to one year from startup
selectCredentialsExpirationDateTimeEdit->setDateTime(QDateTime::currentDateTime().addYears(1));
officialPublicKeyToAddExpirationDateTimeEdit->setDateTime(QDateTime::currentDateTime().addYears(1));
registeredCommunityPublicKeyToAddExpirationTimeDateTimeEdit->setDateTime(QDateTime::currentDateTime().addYears(1));
blacklistPublicKeyExpirationTimeDateTimeEdit->setDateTime(QDateTime::currentDateTime().addYears(1));

//Connect add key buttons to add key dialogs
connect(selectCasterPublicSigningKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(loadCasterConfigurationPublicSigningKey()));
connect(selectCasterPrivateSigningKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(loadCasterConfigurationSecretSigningKey()));
connect(selectKeyManagementPublicSigningKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(loadCasterConfigurationKeyManagementPublicSigningKey()));

connect(selectCredentialsPublicKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(loadCredentialsPublicKey()));
connect(selectCredentialsPublicSigningKey, SIGNAL(clicked(bool)), this, SLOT(addCredentialsSigningPublicKey()));
connect(selectCredentialsPrivateSigningKey, SIGNAL(clicked(bool)), this, SLOT(addCredentialsSigningSecretKey()));

connect(selectKeyManagementPublicKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(loadKeyManagementSigningPublicKey()));
connect(selectKeyManagementPrivateKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(loadKeyManagementSigningSecretKey()));
connect(selectOfficialPublicSigningKeyToAdd, SIGNAL(clicked(bool)), this, SLOT(loadOfficialPublicKeyForKeyManagementRequest()));
connect(selectRegisteredCommunitySigningKeyToAddPushButton, SIGNAL(clicked(bool)), this, SLOT(loadRegisteredCommunityPublicKeyForKeyManagementRequest()));
connect(selectBlackListPublicKey, SIGNAL(clicked(bool)), this, SLOT(loadPublicKeyToBlacklistForKeyManagementRequest()));

connect(saveCasterConfigurationPushButton, SIGNAL(clicked(bool)), this, SLOT(generateCasterConfigurationFile()));
connect(loadCasterConfigurationPushButton, SIGNAL(clicked(bool)), this, SLOT(openCasterConfigurationFile()));

connect(clearSignaturesPushButton, SIGNAL(clicked(bool)), this, SLOT(clearCredentialsSignatureKeys()));
connect(createCredentialsPushButton_2, SIGNAL(clicked(bool)), this, SLOT(createCredentialsFile()));

connect(addOfficialSigningKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(addOfficialSigningKeyToCaster()));
connect(addRegisteredCommunitySigningKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(addRegisteredCommunitySigningKeyToCaster()));
connect(blacklistKeyPushButton, SIGNAL(clicked(bool)), this, SLOT(addSigningKeyToCasterBlacklist()));
} 


/**
This function switches the main GUI's stacked widget to the configureCasterPage.
*/
void casterGUI::switchToConfigureCasterPage()
{
casterConfigurationStackedWidget->setCurrentIndex(0);
}

/**
This function switches the main GUI's stacked widget to the createCredentialsPage.
*/
void casterGUI::switchToCreateCredentialsPage()
{
casterConfigurationStackedWidget->setCurrentIndex(1);
}

/**
This function switches the main GUI's stacked widget to the addRemoveKeysPage.
*/
void casterGUI::switchToAddRemoveKeysPage()
{
casterConfigurationStackedWidget->setCurrentIndex(2);
}

/**
This function opens a file dialog menu to select the base path to generate key pair and emits keyPairGenerationFolderSelected with the selected base path.
*/
void casterGUI::selectDirectoryForKeyPairGeneration()
{
QString qfileName = QFileDialog::getSaveFileName(this, "Save File", QString(pathToFolderToPlaceGeneratedKeyPairIn.c_str()), "");
std::string fileName = qfileName.toStdString();

if(fileName.size() > 0)
{
pathToFolderToPlaceGeneratedKeyPairIn = fileName;
emit keyPairGenerationFolderSelected(fileName);
}
}

/**
This function generates a new signing key pair and outputs it to files with the .pylonPublicKey and .pylonPrivateKey extensions in Z85 text format (ZMQ standard).
@param inputBasePath: The base file name to add the extensions to/write

@throw: This function can throw exceptions
*/
void casterGUI::generateKeyPairFiles(const std::string &inputBasePath)
{
//Generate signing key pair
std::string binaryPublicKey;
std::string binarySecretKey;

std::tie(binaryPublicKey, binarySecretKey) = generateSigningKeys();

//Convert to Z85 format
std::string z85PublicKey;
std::string z85SecretKey;

SOM_TRY
z85PublicKey = convertStringToZ85Format(binaryPublicKey);
SOM_CATCH("Error unable to convert to z85 format\n") 

SOM_TRY
z85SecretKey = convertStringToZ85Format(binarySecretKey);
SOM_CATCH("Error unable to convert to z85 format\n") 

if(!saveStringToFile(z85PublicKey.substr(0, z85PublicKey.size()-1), inputBasePath+".pylonPublicKey"))
{
emit couldNotWriteKeyPairFiles();
return;
}

if(!saveStringToFile(z85SecretKey.substr(0, z85SecretKey.size()-1), inputBasePath+".pylonSecretKey"))
{
emit couldNotWriteKeyPairFiles();
return;
}
}

/**
This function opens up a file dialog to select where to save the current caster settings.  Once the path is selected, it saves.  If something fails, it emits the couldNotWriteConfigurationFile signal.
*/
void casterGUI::generateCasterConfigurationFile()
{
//Get path to save to
QString qPath = QFileDialog::getSaveFileName(this, "Save File", QString(configurationFilePath.c_str()), "Pylon GPS 2.0 Caster Configuration (*.pylonCasterConfiguration)");
std::string path = qPath.toStdString();

if(path.size() == 0)
{
return; //Dialog cancelled
}

//Generate config object
caster_configuration configurationObject;
configurationObject.set_caster_id(std::atoll(casterIDLineEdit->text().toStdString().c_str()));
configurationObject.set_transmitter_registration_and_streaming_port_number(std::atoll(dataSenderPortNumberLineEdit->text().toStdString().c_str()));
configurationObject.set_client_request_port_number(std::atoll(clientRequestPortNumberLineEdit->text().toStdString().c_str()));
configurationObject.set_client_stream_publishing_port_number(std::atoll(clientStreamPublishingPortNumberLineEdit->text().toStdString().c_str()));
configurationObject.set_proxy_stream_publishing_port_number(std::atoll(proxyStreamPublishingPortNumberLineEdit->text().toStdString().c_str()));
configurationObject.set_stream_status_notification_port_number(std::atoll(streamStatusNotificationPortNumberLineEdit->text().toStdString().c_str()));
configurationObject.set_key_registration_and_removal_port_number(std::atoll(keyManagementPortNumberLineEdit->text().toStdString().c_str()));

if(casterConfigurationPublicSigningKey.size() == 0 || casterConfigurationSecretSigningKey.size() == 0 || casterConfigurationKeyManagementPublicSigningKey.size() == 0)
{//Generate keys
std::string casterPublicKey;
std::string casterSecretKey;
std::tie(casterPublicKey, casterSecretKey) = generateSigningKeys();

std::string keyManagementPublicKey;
std::string keyManagementSecretKey;
std::tie(keyManagementPublicKey, keyManagementSecretKey) = generateSigningKeys();

configurationObject.set_caster_public_key(casterPublicKey);
configurationObject.set_caster_secret_key(casterSecretKey);
configurationObject.set_signing_keys_management_key(keyManagementPublicKey);
}
else
{
configurationObject.set_caster_public_key(casterConfigurationPublicSigningKey);
configurationObject.set_caster_secret_key(casterConfigurationSecretSigningKey);
configurationObject.set_signing_keys_management_key(casterConfigurationKeyManagementPublicSigningKey);
}

//Serialize to string
std::string serializedConfigurationObject;
configurationObject.SerializeToString(&serializedConfigurationObject);

//Save in format (Poco::64 bit network int indicating object size), object
Poco::Int64 objectSizeNetworkOrder = Poco::ByteOrder::toNetwork(Poco::Int64(serializedConfigurationObject.size()));

//Save to file
if(!saveStringToFile(std::string((char *) &objectSizeNetworkOrder, sizeof(Poco::Int64)) + serializedConfigurationObject, path+".pylonCasterConfiguration"))
{
emit couldNotWriteConfigurationFile();
}
}

/**
This function opens a file dialog to select a caster configuration file to open.  Once the file is loaded, it puts the values into the configuration menu for modification/saving.  If something fails, it emits the couldNotReadConfigurationFile() signal. 
*/
void casterGUI::openCasterConfigurationFile()
{
//Get path
QString qPath;
qPath = QFileDialog::getOpenFileName(this, "Open Configuration file", QString(configurationFilePath.c_str()), "Caster configuration file (*.pylonCasterConfiguration)");
std::string path = qPath.toStdString();

//Read size of object in file
std::string sizeString;
if(readStringFromFile(sizeString, sizeof(Poco::Int64), path) == false) 
{
emit couldNotReadConfigurationFile();
return;
}

Poco::Int64 objectSizeNetworkOrder = *((Poco::Int64 *) sizeString.c_str());
Poco::Int64 objectSize = Poco::ByteOrder::fromNetwork(objectSizeNetworkOrder);

//Read size+object
std::string sizeAndObjectString;
if(readStringFromFile(sizeAndObjectString, sizeof(Poco::Int64)+objectSize, path) == false || objectSize == 0) 
{
emit couldNotReadConfigurationFile();
return;
}

std::string objectString = sizeAndObjectString.substr(sizeof(Poco::Int64));

//Deserialize the protobuf object
caster_configuration configuration;

configuration.ParseFromString(objectString);

if(!configuration.IsInitialized())
{
emit couldNotReadConfigurationFile();
return;
}

//Check that all required fields are there
if(!configuration.has_caster_id() || !configuration.has_transmitter_registration_and_streaming_port_number() || !configuration.has_client_request_port_number() || !configuration.has_client_stream_publishing_port_number() || !configuration.has_proxy_stream_publishing_port_number() || !configuration.has_stream_status_notification_port_number() || !configuration.has_key_registration_and_removal_port_number() || !configuration.has_caster_public_key() || !configuration.has_caster_secret_key() || !configuration.has_signing_keys_management_key())
{
emit couldNotReadConfigurationFile();
return;
}

//Valid configuration has been received
configurationFilePath = path;
casterIDLineEdit->setText(QString(std::to_string(configuration.caster_id()).c_str()));
dataSenderPortNumberLineEdit->setText(QString(std::to_string(configuration.transmitter_registration_and_streaming_port_number()).c_str()));
clientRequestPortNumberLineEdit->setText(QString(std::to_string(configuration.client_request_port_number()).c_str()));
clientStreamPublishingPortNumberLineEdit->setText(QString(std::to_string(configuration.client_stream_publishing_port_number()).c_str()));
proxyStreamPublishingPortNumberLineEdit->setText(QString(std::to_string(configuration.proxy_stream_publishing_port_number()).c_str()));
streamStatusNotificationPortNumberLineEdit->setText(QString(std::to_string(configuration.stream_status_notification_port_number()).c_str()));
keyManagementPortNumberLineEdit->setText(QString(std::to_string(configuration.key_registration_and_removal_port_number()).c_str()));

casterConfigurationPublicSigningKey = configuration.caster_public_key();
casterConfigurationSecretSigningKey = configuration.caster_secret_key();
casterConfigurationKeyManagementPublicSigningKey = configuration.signing_keys_management_key();
}

/**
This function removes all of the keys that have been stored for signing credentials.
*/
void casterGUI::clearCredentialsSignatureKeys()
{
credentialsSigningPublicKeys.clear();
credentialsSigningPrivateKeys.clear();
}

/**
This function opens a file dialog and then generates/saves a credentials file based on the keys that have been loaded.  It emits a couldNotWriteCredentialsFile signal if there was not enough information loaded or a operation failed.
*/
void casterGUI::createCredentialsFile()
{
//Check that a public key to sign has been loaded and that at least one signature file has been loaded
if(credentialsPublicKey.size() == 0 || credentialsSigningPublicKeys.size() == 0 || credentialsSigningPrivateKeys.size() == 0)
{
emit couldNotWriteCredentialsFile();
return;
}

authorized_permissions permissions;
permissions.set_public_key(credentialsPublicKey);
permissions.set_valid_until(selectCredentialsExpirationDateTimeEdit->dateTime().toMSecsSinceEpoch()*1000); //Microseconds since epoc
permissions.set_number_of_permitted_base_stations(std::atoll(selectCredentialsBasestationLimit->text().toStdString().c_str())); 

std::string serializedPermissions;
permissions.SerializeToString(&serializedPermissions);

//Generate signatures
unsigned char cryptoSignature[crypto_sign_BYTES];
std::vector<signature> signatures;
for(int i=0; i<credentialsSigningPublicKeys.size() && i<credentialsSigningPrivateKeys.size(); i++)
{
crypto_sign_detached(cryptoSignature, nullptr, (const unsigned char *) serializedPermissions.c_str(), serializedPermissions.size(), (const unsigned char *) credentialsSigningPrivateKeys[i].c_str());

signature generatedSignature;
generatedSignature.set_public_key(credentialsSigningPublicKeys[i]);
generatedSignature.set_cryptographic_signature(std::string((char *) cryptoSignature, crypto_sign_BYTES));

signatures.push_back(generatedSignature);
}

//Create and serialize credentials object
std::string serializedCredentialsObject;
credentials credentialsObject;
credentialsObject.set_permissions(serializedPermissions);

//Add signatures
for(int i=0; i<signatures.size(); i++)
{
*(credentialsObject.add_signatures()) = signatures[i];
}

credentialsObject.SerializeToString(&serializedCredentialsObject);

//Create serialized object size
Poco::Int64 credentialsObjectSizeNetworkOrder = Poco::ByteOrder::toNetwork(Poco::Int64(serializedCredentialsObject.size()));

//Open file dialog
QString qPath = QFileDialog::getSaveFileName(this, "Save Credentials", QString(credentialsFilePath.c_str()), "Pylon Credentials File (*.pylonCredentials)");
std::string path = qPath.toStdString();
credentialsFilePath = path;

//Save to file
if(!saveStringToFile(std::string((char *) &credentialsObjectSizeNetworkOrder, sizeof(Poco::Int64)) + serializedCredentialsObject, path+".pylonCredentials"))
{
emit couldNotWriteCredentialsFile();
return;
}
}

/**
This function adds a Official Signing key to the caster whose IP address/key management port has been entered.  This function makes a network call and waits a maximum of .25 seconds for it to send a response back.  This can cause the GUI to hang for a little bit.
*/
void casterGUI::addOfficialSigningKeyToCaster()
{

if(sendKeyManagementRequest(casterIPAddressLineEdit->text().toStdString(), casterPortLineEdit->text().toStdString(), keyManagementPublicKeyToUse, keyManagementPrivateKeyToUse, officialPublicKeyToAdd, ADD_OFFICIAL_SIGNING_KEY, officialPublicKeyToAddExpirationDateTimeEdit->dateTime().toMSecsSinceEpoch()*1000, .25) == false)
{
emit couldNotAddOfficialKeyToCaster();
return;
}

}

/**
This function adds a Registered Community Signing key to the caster whose IP address/key management port has been entered.  This function makes a network call and waits a maximum of .25 seconds for it to send a response back.  This can cause the GUI to hang for a little bit.
*/
void casterGUI::addRegisteredCommunitySigningKeyToCaster()
{

if(sendKeyManagementRequest(casterIPAddressLineEdit->text().toStdString(), casterPortLineEdit->text().toStdString(), keyManagementPublicKeyToUse, keyManagementPrivateKeyToUse, registeredCommunityPublicKeyToAdd, ADD_REGISTERED_COMMUNITY_SIGNING_KEY, registeredCommunityPublicKeyToAddExpirationTimeDateTimeEdit->dateTime().toMSecsSinceEpoch()*1000, .25) == false)
{
emit couldNotAddRegistedCommunityKeyToCaster();
return;
}

}

/**
This function adds a Signing key the black list maintained by the caster whose IP address/key management port has been entered.  This function makes a network call and waits a maximum of .25 seconds for it to send a response back.  This can cause the GUI to hang for a little bit.
*/
void casterGUI::addSigningKeyToCasterBlacklist()
{

if(sendKeyManagementRequest(casterIPAddressLineEdit->text().toStdString(), casterPortLineEdit->text().toStdString(), keyManagementPublicKeyToUse, keyManagementPrivateKeyToUse, publicKeyToAddToBlacklist, BLACKLIST_SIGNING_KEY, blacklistPublicKeyExpirationTimeDateTimeEdit->dateTime().toMSecsSinceEpoch()*1000, .25) == false)
{
emit couldNotAddKeyToCasterBlacklist();
return;
}

}

/**
This function loads the public signing key to assign to the caster.
*/
void casterGUI::loadCasterConfigurationPublicSigningKey()
{
runKeyLoadDialogForString(casterConfigurationPublicSigningKey, true, lastPublicKeyPath);
}

/**
This function loads the secret signing key to assign to the caster.
*/
void casterGUI::loadCasterConfigurationSecretSigningKey()
{
runKeyLoadDialogForString(casterConfigurationSecretSigningKey, false, lastSecretKeyPath);
}

/**
This function loads the public signing key to assign to the caster.
*/
void casterGUI::loadCasterConfigurationKeyManagementPublicSigningKey()
{
runKeyLoadDialogForString(casterConfigurationKeyManagementPublicSigningKey, true, lastPublicKeyPath);
}

/**
This function loads the public key to generate a credentials message for.
*/
void casterGUI::loadCredentialsPublicKey()
{
runKeyLoadDialogForString(credentialsPublicKey, true, lastPublicKeyPath);
}

/**
This function loads a public key to sign the credentials with.
*/
void casterGUI::addCredentialsSigningPublicKey()
{
std::string keyBuffer;
if(runKeyLoadDialogForString(keyBuffer, true, lastPublicKeyPath) == true)
{
credentialsSigningPublicKeys.push_back(keyBuffer);
}
}

/**
This function loads a secret key to sign the credentials with.
*/
void casterGUI::addCredentialsSigningSecretKey()
{
std::string keyBuffer;
if(runKeyLoadDialogForString(keyBuffer, false, lastSecretKeyPath) == true)
{
credentialsSigningPrivateKeys.push_back(keyBuffer);
}
}

/**
This function loads the key management public key to use with key management requests.
*/
void casterGUI::loadKeyManagementSigningPublicKey()
{
runKeyLoadDialogForString(keyManagementPublicKeyToUse, true, lastPublicKeyPath);
}

/**
This function loads the key management key to use with key management requests.
*/
void casterGUI::loadKeyManagementSigningSecretKey()
{
runKeyLoadDialogForString(keyManagementPrivateKeyToUse, false, lastSecretKeyPath);
}

/**
This function loads a public key to add to the Official list using a key managment request.
*/
void casterGUI::loadOfficialPublicKeyForKeyManagementRequest()
{
runKeyLoadDialogForString(officialPublicKeyToAdd, true, lastPublicKeyPath);
}

/**
This function loads a public key to add to the Registered Community list using a key managment request.
*/
void casterGUI::loadRegisteredCommunityPublicKeyForKeyManagementRequest()
{
runKeyLoadDialogForString(registeredCommunityPublicKeyToAdd, true, lastPublicKeyPath);
}

/**
This function loads a public key to add to the black list using a key managment request.
*/
void casterGUI::loadPublicKeyToBlacklistForKeyManagementRequest()
{
runKeyLoadDialogForString(publicKeyToAddToBlacklist, true, lastPublicKeyPath);
}

/**
This function opens a dialog box asking for a key file, with the default path being given by inputPathStartFormAt.  If a proper key file is selected and is valid, it loads the key into the string given by inputKeyStringToLoadTo.
@param inputKeyStringToLoadTo: The string buffer to load the decoded string into
@param inputIsPublicKey: True if the key to load is a public key and false if it is a private key
@param inputPathToStartFormAt: A string containing where the file dialog should start looking (typically last variable loaded).  The selected path will be saved to this variable
@return: True if this function loaded a key
*/
bool casterGUI::runKeyLoadDialogForString(std::string &inputKeyStringToLoadTo, bool inputIsPublicKey, std::string &inputPathStartFormAt)
{
QString qPath;
if(inputIsPublicKey)
{
qPath = QFileDialog::getOpenFileName(this, "Open Public Key File", QString(inputPathStartFormAt.c_str()), "Public Keys (*.pylonPublicKey)");
}
else
{
qPath = QFileDialog::getOpenFileName(this, "Open Secret Key File", QString(inputPathStartFormAt.c_str()), "Secret Keys (*.pylonSecretKey)");
}
std::string path = qPath.toStdString();

//Try loading the key
std::string loadedKey;
if(inputIsPublicKey)
{
loadedKey = loadPublicKeyFromFile(path);
if(loadedKey.size() == 0)
{
emit couldNotReadPublicKeyFile();
}
}
else
{
loadedKey = loadSecretKeyFromFile(path);
if(loadedKey.size() == 0)
{
emit couldNotReadSecretKeyFile();
}
}

//Key loaded OK
inputKeyStringToLoadTo = loadedKey;
inputPathStartFormAt = path;
return true;
}


/**
This function generates a key mangement request, sends it to the specified caster and verifies if the request succeeded.
@param inputCasterIPAddressString: A string containing the IP address to send to
@param inputCasterKeyManagementPortString: A string containing the key management port to send to
@param inputKeyManagementPublicKey: The public key associated with the caster's key management port
@param inputKeyMangementSecretKey: The secret key associated with the caster's key managment port
@param inputKeyToSendRequestFor: The key to do the key management operation for
@param inputTypeOfKeyManagementRequest: The type of operation to perform with the given key
@param inputRequestValidUntil:  When the requested change will expire (int Milliseconds since the Unix epoch)
@param inputMaximumResponseDelay: How long in seconds to wait for the reply
@return: true if the request succeeded and false otherwise
*/
bool casterGUI::sendKeyManagementRequest(const std::string &inputCasterIPAddressString, const std::string &inputCasterKeyManagementPortString, const std::string &inputKeyManagementPublicKey, const std::string &inputKeyManagementSecretKey, const std::string inputKeyToSendRequestFor, keyManagementRequestType inputTypeOfKeyManagementRequest, int64_t inputRequestValidUntil, double inputMaximumResponseDelay)
{
//Check that the required keys have been inserted
if(inputCasterIPAddressString.size() == 0 || inputCasterKeyManagementPortString.size() == 0 || inputKeyManagementPublicKey.size() == 0 || inputKeyManagementSecretKey.size() == 0)
{
return false;
}

//Create socket with a connection to the key manager
std::unique_ptr<zmq::socket_t> requestSocket;
try
{
requestSocket.reset(new zmq::socket_t(context, ZMQ_REQ));
int maxWaitTime = inputMaximumResponseDelay*1000 + .5; //Convert to milliseconds

SOM_TRY
requestSocket->setsockopt(ZMQ_RCVTIMEO, (void *) &maxWaitTime, sizeof(maxWaitTime));
SOM_CATCH("Error setting timeout time\n")

SOM_TRY
requestSocket->connect(("tcp://" + inputCasterIPAddressString + ":" + inputCasterKeyManagementPortString).c_str());
SOM_CATCH("Error connecting socket\n")
}
catch(const std::exception &inputException)
{
return false;
}

//Construct request
std::string serializedChangesToMake;
key_status_changes changesToMake;
if(inputTypeOfKeyManagementRequest == ADD_OFFICIAL_SIGNING_KEY)
{
(*changesToMake.add_official_signing_keys_to_add()) = inputKeyToSendRequestFor;
changesToMake.add_official_signing_keys_to_add_valid_until(inputRequestValidUntil);
}
else if(inputTypeOfKeyManagementRequest == ADD_REGISTERED_COMMUNITY_SIGNING_KEY)
{
(*changesToMake.add_registered_community_signing_keys_to_add()) = inputKeyToSendRequestFor;
changesToMake.add_registered_community_signing_keys_to_add_valid_until(inputRequestValidUntil);
}
else
{
(*changesToMake.add_keys_to_add_to_blacklist()) = inputKeyToSendRequestFor;
changesToMake.keys_to_add_to_blacklist_valid_until(inputRequestValidUntil);
}

changesToMake.SerializeToString(&serializedChangesToMake);

//Generate signature
unsigned char cryptoSignature[crypto_sign_BYTES];
crypto_sign_detached(cryptoSignature, nullptr, (const unsigned char *) serializedChangesToMake.c_str(), serializedChangesToMake.size(), (const unsigned char *) inputKeyManagementSecretKey.c_str());

signature keyManagementSignature;
keyManagementSignature.set_public_key(inputKeyManagementPublicKey);
keyManagementSignature.set_cryptographic_signature(std::string((char *) cryptoSignature, crypto_sign_BYTES));

key_management_request request;
request.set_serialized_key_status_changes(serializedChangesToMake);
(*request.mutable_signature()) = keyManagementSignature;

key_management_reply reply;

//Send request and get reply
bool replyReceived = false;
bool replyDeserializedCorrectly = false;

try
{
std::tie(replyReceived, replyDeserializedCorrectly) = remoteProcedureCall(*requestSocket, request, reply);
}
catch(const std::exception &inputException)
{
return false;
}

if(replyReceived == false || replyDeserializedCorrectly == false)
{
return false;
}

if(reply.request_succeeded() == false)
{
return false;
}

return true;
}

