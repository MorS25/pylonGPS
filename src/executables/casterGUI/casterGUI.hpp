#pragma once

#include<QMainWindow>
#include "ui_casterConfigurationWindowTemplate.h"
#include<QPushButton>
#include<QStackedWidget>
#include<QFileDialog>
#include<sodium.h>
#include "zmq.hpp"
#include "SOMException.hpp"
#include "utilityFunctions.hpp"
#include "caster_configuration.pb.h"
#include "Poco/ByteOrder.h"

#include<climits>
#include<string>
#include<memory>
#include<cstdlib>



namespace pylongps
{


/**
This class is the main window used with the pylon GPS 2.0 tranceiver.  It is written to use Qt4 with the Marble GIS library because that is what is currently available in the Ubuntu repositories.
*/
class casterGUI : public QMainWindow, public Ui::casterConfigurationWindowTemplate
{
Q_OBJECT

public:

/**
This function initializes the class, connecting widgets, setting up the form generated by Qt designer and adding the components that the designer doesn't handle well.

@throw: This function can throw exceptions
*/
casterGUI();

public slots:
/**
This function switches the main GUI's stacked widget to the configureCasterPage.
*/
void switchToConfigureCasterPage();

/**
This function switches the main GUI's stacked widget to the createCredentialsPage.
*/
void switchToCreateCredentialsPage();

/**
This function switches the main GUI's stacked widget to the addRemoveKeysPage.
*/
void switchToAddRemoveKeysPage();

/**
This function opens a file dialog menu to select the base path to generate key pair and emits keyPairGenerationFolderSelected with the selected base path.
*/
void selectDirectoryForKeyPairGeneration();

/**
This function generates a new signing key pair and outputs it to files with the .pylonPublicKey and .pylonPrivateKey extensions in Z85 text format (ZMQ standard).
@param inputBasePath: The base file name to add the extensions to/write

@throw: This function can throw exceptions
*/
void generateKeyPairFiles(const std::string &inputBasePath);

/**
This function opens up a file dialog to select where to save the current caster settings.  Once the path is selected, it saves.  If something fails, it emits the couldNotWriteConfigurationFile signal.
*/
void generateCasterConfigurationFile();

/**
This function opens a file dialog to select a caster configuration file to open.  Once the file is loaded, it puts the values into the configuration menu for modification/saving.  If something fails, it emits the couldNotReadConfigurationFile() signal. 
*/
void openCasterConfigurationFile();

/**
This function loads the public signing key to assign to the caster.
*/
void loadCasterConfigurationPublicSigningKey();

/**
This function loads the secret signing key to assign to the caster.
*/
void loadCasterConfigurationSecretSigningKey();

/**
This function loads the public signing key to assign to the caster.
*/
void loadCasterConfigurationKeyManagementPublicSigningKey();

/**
This function loads the public key to generate a credentials message for.
*/
void loadCredentialsPublicKey();

/**
This function loads a public key to sign the credentials with.
*/
void addCredentialsSigningPublicKey();

/**
This function loads a secret key to sign the credentials with.
*/
void addCredentialsSigningSecretKey();

/**
This function loads the key management key to use with key management requests.
*/
void loadKeyManagementSigningSecretKey();

/**
This function loads a public key to add to the Official list using a key managment request.
*/
void loadOfficialPublicKeyForKeyManagementRequest();

/**
This function loads a public key to add to the Registered Community list using a key managment request.
*/
void loadRegisteredCommunityPublicKeyForKeyManagementRequest();

/**
This function loads a public key to add to the black list using a key managment request.
*/
void loadPublicKeyToBlacklistForKeyManagementRequest();

signals:
void keyPairGenerationFolderSelected(std::string);

void couldNotWriteKeyPairFiles();

void couldNotReadPublicKeyFile();

void couldNotReadSecretKeyFile();

void couldNotReadConfigurationFile();

void couldNotWriteConfigurationFile();

protected:
/**
This function opens a dialog box asking for a key file, with the default path being given by inputPathStartFormAt.  If a proper key file is selected and is valid, it loads the key into the string given by inputKeyStringToLoadTo.
@param inputKeyStringToLoadTo: The string buffer to load the decoded string into
@param inputIsPublicKey: True if the key to load is a public key and false if it is a private key
@param inputPathToStartFormAt: A string containing where the file dialog should start looking (typically last variable loaded).  The selected path will be saved to this variable
@return: True if this function loaded a key
*/
bool runKeyLoadDialogForString(std::string &inputKeyStringToLoadTo, bool inputIsPublicKey, std::string &inputPathStartFormAt);

//Save last secret, public key path loaded 
std::string lastPublicKeyPath;
std::string lastSecretKeyPath;

//Caster configuration page variables
std::string casterConfigurationPublicSigningKey;
std::string casterConfigurationSecretSigningKey;
std::string casterConfigurationKeyManagementPublicSigningKey;
std::string configurationFilePath;

//Generate key pair variables
std::string pathToFolderToPlaceGeneratedKeyPairIn;

//Generate Credentials message
std::string credentialsPublicKey;
std::vector<std::string> credentialsSigningPublicKeys;
std::vector<std::string> credentialsSigningPrivateKeys;

//Send key management requests
std::string keyManagementPrivateKeyToUse;
std::string officialPublicKeyToAdd;
std::string registeredCommunityPublicKeyToAdd;
std::string publicKeyToBlacklist;
};















}
