Switch from Qt Quick with Qt localization to Qt5 widgets with Marble to speed development.

Design GUI without animations to start, with possibility of adding them later.

Make Marble widget that can show streets/cities. -> done

Create basic layout similar to the planned qml layout. -> done

Test mode switching capability -> done

Figure out how to have items show up both on the map and the sidebars

Create caster and some dummy basestations.

Create code to query caster and place basestation results in sidebar

Experiment with expandable representations

Create representations of local data sources

Create representation of data senders

Create code to allow connection of data sources to data senders

Create gui to show which senders are connected to which senders.


http://doc.qt.io/qt-4.8/animation-overview.html

Caster requirements/workflow:
Create GUI to manage caster.  Said GUI creates a protobuf based config file which can then be passed to the command line based Pylon GPS 2.0 caster program.  It will also have the option to generate public/private key pairs and generate credentials messages for a given key to grant it certain permissions.  Lastly, it allows connecting to a Pylon GPS 2.0 caster to add/remove keys.

Breaking down functionality:

Generate configuration file

Generate plain text public/private key pairs (define format, likly one of the hex encoding formats -> fprintf might work).

Create credentials to authorize a signing key -> message type already defined

Connect to a Pylon GPS 2.0 caster and add/remove keys -> need seperate network thread.


Rebuilding SQLite interface:

The first time a class is encountered, storage/retrieval statements are created for it.

Simple case, no submessages stored:

The first integer field encountered (lowest field number) is considered the primary key for the the message.  If there is an attempt to store an object without the primary key field, an exception will be thrown.

Iterate through the fields and create a column entry for each optional or required field.  

For each repeated field, a new table is created of format messageName__repeatedFieldName.  Each row in the repeated field table contains a foreign key which points back to the message__table and cascade delete is enabled.

At the end of the creation process, the following entries in the interface have been made:

struct messageInterface
{
std::pair<std::vector<fieldNumbers>, sqlite_statment_to_insert_primary_row> //Field numbers representing optional
}

std::map<messageName, messageInterface>


